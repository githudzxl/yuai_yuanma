/* This file was generated by the Hex-Rays decompiler version 9.3.0.251224.
   Copyright (c) 2007-2025 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int sub_140001000();
int sub_140001030();
int sub_140001040();
int sub_140001050();
int sub_140001060();
int sub_14000106C();
__int64 __fastcall sub_140001080(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400010C0(_QWORD); // weak
const char *__fastcall sub_1400010E0(__int64 a1);
char *__fastcall sub_140001100(char *Block, char a2);
_QWORD *__fastcall sub_140001150(_QWORD *a1);
void __fastcall __noreturn sub_140001180(_QWORD); // weak
__int64 __fastcall sub_1400011A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400011E0(__int64 a1, __int64 a2);
void __fastcall sub_140001220(_QWORD *a1, __int64 a2);
__int64 __fastcall sub_140001310(_QWORD); // weak
void __fastcall sub_140001370(__int64 a1, _BYTE *a2, const void *a3, size_t a4);
_BYTE *__fastcall sub_1400015A0(_QWORD *a1, _BYTE *a2, _BYTE *a3);
void __fastcall __noreturn sub_140001720(_QWORD); // weak
void __noreturn sub_140001740(void); // weak
__int64 __fastcall sub_140001760(__int64 a1, __int64 a2, unsigned int a3);
_QWORD *__fastcall sub_140001A30(_QWORD *Block, char a2);
__int64 __fastcall sub_140001AD0(_QWORD *a1);
__int64 __fastcall sub_140001B50(_QWORD); // weak
__int64 __fastcall sub_140001BB0(__int64 a1);
__int64 *__fastcall sub_140001BC0(__int64 *a1, const char *a2);
__int64 __fastcall sub_140001D90(_QWORD); // weak
__int64 __fastcall sub_140001E00(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sub_140001F20(__int64 a1, unsigned __int64 *a2, _QWORD *a3, char a4);
_QWORD *__fastcall sub_140002050(__int64 a1, _QWORD *a2, __int64 a3, int a4, char a5);
__int64 __fastcall sub_1400021F0(__int64 a1);
__int64 __fastcall sub_140002250(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1400022B0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_1400024B0(__int64 a1);
void *__fastcall sub_140002580(__int64 a1, char a2);
__int64 *__fastcall sub_140002650(__int64 *a1, __int64 a2, unsigned __int64 a3);
void **__fastcall sub_140002890(void **a1, const void *a2, size_t a3);
void *__fastcall sub_1400029EC(__int64 a1, char a2);
void __fastcall sub_140002A00(__int64 a1);
__int64 __fastcall sub_140002A80(__int64 a1, __int64 a2);
__int64 __fastcall sub_140002AE0(__int64 a1, DWORD a2);
__int64 __fastcall sub_140002CE0(_QWORD); // weak
void __fastcall sub_140002D20(__int64 a1);
__int64 __fastcall sub_1400034F0(__int64 a1);
__int64 __fastcall sub_1400036A0(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_140003970(__int64 a1, size_t a2);
__int64 __fastcall sub_140003CB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140003E90(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400040B0(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1400042B0(__int64 a1, _QWORD *a2, __int64 a3);
CHAR *__fastcall sub_140004690(__int64 a1, CHAR *a2, __int64 a3);
__int64 __fastcall sub_140004700(__int64 a1, __int64 a2);
__int64 __fastcall sub_140004970(__int64 a1, __int64 a2, _QWORD *a3);
_QWORD *__fastcall sub_140004CB0(__int64 a1, _QWORD *a2, int a3, int a4, _QWORD *a5);
_QWORD *__fastcall sub_140005040(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5);
_QWORD *__fastcall sub_1400054C0(_QWORD *a1, const char *a2, _QWORD *a3);
_QWORD *__fastcall sub_140005540(_QWORD *a1, _QWORD *a2, __int64 a3);
__int64 __fastcall sub_1400055A0(__int64 a1, void **a2, const char *a3);
__int64 __fastcall sub_140005610(__int64 a1, void **a2, _QWORD *a3);
__int64 __fastcall sub_140005680(_QWORD); // weak
// __int64 __fastcall unknown_libname_9(_QWORD, _QWORD, _QWORD); weak
__int64 __fastcall sub_140005720(_QWORD); // weak
_QWORD *__fastcall sub_140005790(_QWORD *a1, __int64 a2);
void __fastcall sub_140005870(void **a1);
__int64 __fastcall sub_1400058A0(_QWORD *a1, size_t *a2);
__int64 __fastcall sub_1400058C0(__int64 a1);
void __fastcall sub_1400058D0(__int64 *a1);
_QWORD *__fastcall sub_140005950(_QWORD *a1, size_t a2);
_QWORD *__fastcall sub_140005A60(_QWORD *a1, const char *a2);
__int64 __fastcall sub_140005AB0(_QWORD *a1, __int64 a2, size_t *a3);
__int64 __fastcall sub_140005CF0(_QWORD *a1, __int64 a2, size_t *a3);
void *__fastcall sub_140005F50(_QWORD *a1, const void *a2, size_t a3);
void __fastcall sub_140006050(__int64 a1, __int64 a2);
_QWORD *__fastcall sub_1400060D0(_QWORD *a1, __int64 a2, __int64 a3, const void *a4, size_t Size, void *Src, size_t a7);
_QWORD *__fastcall sub_1400061F0(_QWORD *a1, _QWORD *a2, size_t *a3, __int64 a4);
void __fastcall sub_1400062C0(char **a1, char **a2);
void __fastcall sub_140006350(__int64 a1, _QWORD **a2);
void **__fastcall sub_1400063F0(void **Src, const void *a2, unsigned __int64 a3);
__int64 __fastcall sub_140006510(__int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_140006650(float *a1);
void **__fastcall sub_140006700(void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size);
unsigned __int64 __fastcall sub_1400068B0(_QWORD *a1, unsigned __int64 a2);
void *sub_140006B40();
int sub_140006B50(const char *a1, ...);
_QWORD *__fastcall sub_140006BB0(_QWORD *a1);
void __noreturn sub_140006BE0(void); // weak
__int64 __fastcall sub_140006C00(__int64 a1, __int64 a2);
__int64 __fastcall sub_140006C40(_QWORD); // weak
_QWORD *__fastcall sub_140006C70(_QWORD *a1);
__int64 __fastcall sub_140006E90(_QWORD); // weak
_QWORD *__fastcall sub_140006EF0(_QWORD *a1);
int __fastcall main(int argc, const char **argv, const char **envp);
__int64 __fastcall sub_140007940(_QWORD); // weak
char __fastcall sub_1400079B0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140007A00(FILE **a1);
__int64 __fastcall sub_140007A50(__int64 a1, char *a2, size_t a3);
fpos_t *__fastcall sub_140007B50(__int64 a1, fpos_t *a2, _QWORD *a3);
fpos_t *__fastcall sub_140007C30(__int64 a1, fpos_t *a2, __int64 a3, int a4);
__int64 __fastcall sub_140007D40(__int64 a1, char *a2, __int64 a3);
__int64 __fastcall sub_140007E10(__int64 a1, char *a2, __int64 a3);
__int64 __fastcall sub_140007F60(__int64 a1);
__int64 __fastcall sub_140008230(__int64 a1);
__int64 __fastcall sub_1400082A0(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140008390(__int64 a1, unsigned int a2);
void __fastcall sub_140008550(__int64 a1);
void __fastcall sub_140008570(__int64 a1);
__int64 __fastcall sub_140008590(__int64 a1);
void *__fastcall sub_140008670(__int64 a1, char a2);
void *__fastcall sub_140008700(void *Block, char a2);
char *__fastcall sub_140008740(char **a1, unsigned __int64 a2);
__int64 __fastcall sub_1400088D0(__int64 a1);
__int64 __fastcall sub_140008A20(__int64 a1, const char *a2);
bool __fastcall sub_140008C30(__int64 a1);
_DWORD *__fastcall sub_140008D20(_QWORD *a1, _BYTE *a2, _DWORD *a3);
void **__fastcall sub_140008EC0(void **Src, __int64 a2, __int64 a3, char a4);
void *__fastcall sub_140009024(__int64 a1, char a2);
__int64 __fastcall sub_140009030(__int64 a1, __int64 a2);
void __fastcall sub_1400090C0(__int64 a1);
__int64 __fastcall sub_140009170(_QWORD); // weak
_QWORD *__fastcall sub_1400091C0(HANDLE *a1, _QWORD *a2, const void *a3, size_t a4);
CHAR *__fastcall sub_1400093B0(HANDLE *a1, CHAR *a2, const void *a3, size_t a4);
__int64 __fastcall sub_140009720(HANDLE *a1, const void *a2);
LPVOID __fastcall sub_1400097D0(__int64 a1, __int64 a2);
LPVOID __fastcall sub_140009940(__int64 a1, const void **a2);
LPVOID __fastcall sub_140009AC0(__int64 a1);
LPVOID __fastcall sub_140009B80(__int64 a1);
void __fastcall sub_140009C40(void **a1);
__int64 __fastcall sub_140009CA0(_QWORD); // weak
__int64 __fastcall sub_140009D10(_QWORD *a1, __int64 a2, unsigned __int8 *a3);
_QWORD *__fastcall sub_140009FE0(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall sub_14000A1D0(__int64 a1, void *a2, __int64 a3);
char __fastcall sub_14000A980(void *a1, HMODULE *a2);
char *__fastcall sub_14000AD60(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
__int64 __fastcall sub_14000B090(_QWORD); // weak
__int64 __fastcall sub_14000B150(const __m128i *Src, size_t Size, __m128i *a3, unsigned __int64 a4);
const __m128i *__fastcall sub_14000B390(const __m128i *a1, const __m128i *a2, unsigned __int8 a3);
__int64 __fastcall sub_14000B490(const __m128i *Src, size_t Size, const __m128i *a3, size_t a4);
int __fastcall sub_14000B6B0(char *a1, unsigned __int64 a2);
char __fastcall sub_14000B810(unsigned __int64 a1, unsigned __int64 a2, char a3);
const __m128i *__fastcall sub_14000B8A0(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4);
__int64 __fastcall sub_14000BA90(void *Src, size_t Size, void *, size_t); // idb
const __m128i *__fastcall sub_14000BAA0(const __m128i *, const __m128i *, unsigned __int8);
__int64 __fastcall sub_14000BAB0(_QWORD, _QWORD, _QWORD, _QWORD); // weak
void *__fastcall sub_14000BABC(__int64 a1);
// void std::_Xbad_alloc(); idb
// void *__fastcall operator new(size_t Size); idb
void __cdecl j_j_free(void *Block);
_QWORD *__fastcall sub_14000BB7C(_QWORD *a1, char a2);
// int __cdecl atexit(void (__cdecl *)());
__int64 __fastcall sub_14000C07C(__int64 a1, __int64 a2);
__int64 sub_14000C0E0(); // weak
_QWORD *__fastcall sub_14000C388(_QWORD *a1);
void __noreturn sub_14000C3AC(); // weak
__int64 __fastcall UserMathErrorFunction(struct _exception *a1);
bool sub_14000C3F4();
__int64 sub_14000C4B4(); // weak
void sub_14000C56C();
char sub_14000C57C();
void *sub_14000C580();
void *sub_14000C5B0();
void *sub_14000C5B8();
void sub_14000C5C0();
void __fastcall sub_14000C5FC();
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
// void *__cdecl memmove(void *, const void *Src, size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// void __stdcall __noreturn CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// float __cdecl ceilf(float X);
// size_t __cdecl strlen(const char *Str);
__int64 __fastcall sub_14000C850(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C8AF(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C950(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C9A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C9AC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000C9E0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CA88(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CAA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CAC4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CAD0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CAF4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB00(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB0C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB24(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB30(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB48(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB54(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB60(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB6C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB78(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CB84(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CBA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC18(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC3C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC48(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC54(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC6C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CC78(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CCD4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CCE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CCEC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CD00(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CD0C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CD2C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CD60(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDBC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDC8(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDD4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDE0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDEC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CDF8(__int64 a1, __int64 a2);
void __fastcall sub_14000CE50(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CEC0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CEF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CEFC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF10(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF1C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF28(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF40(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF50(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF5C(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CF70(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000CFF9(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D005(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D011(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D01D(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D029(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D035(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D041(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D04D(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D059(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D065(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D071(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D0A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D0AC(__int64 a1, __int64 a2);
__int64 __fastcall sub_14000D0C0(__int64 a1, __int64 a2);
void __fastcall sub_14000D110();
void sub_14000D180();
void sub_14000D1F0();
void sub_14000D260();
void sub_14000D2D0();
void sub_14000D33C();
// __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::ios::ios(_QWORD); weak
// __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::ostream::ostream(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::streambuf::~streambuf<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::ostream::_Osfx(_QWORD); weak
// __int64 std::streambuf::xsgetn(void); weak
// __int64 std::streambuf::xsputn(void); weak
// __int64 __fastcall std::ostream::~ostream<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::ostream::operator<<(_QWORD, _QWORD); weak
// bool std::ios_base::good(std::ios_base *__hidden this); weak
// void std::_Lockit::~_Lockit(std::_Lockit *__hidden this); weak
// _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD); weak
// __int64 std::locale::_Getgloballocale(void); weak
// struct _iobuf *std::_Fiopen(const char *, _DWORD, _DWORD); weak
// __int64 __fastcall std::streambuf::getloc(_QWORD, _QWORD); weak
// __int64 __fastcall std::streambuf::_Init(_QWORD); weak
// __int64 __fastcall std::streambuf::_Init(_QWORD); weak
// __int64 __fastcall std::istream::istream(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,_Mbstatet>::unshift(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,_Mbstatet>::_Getcat(_QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,_Mbstatet>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::codecvt<char,char,_Mbstatet>::out(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD); weak
// __int64 __fastcall std::istream::read(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::istream::seekg(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::istream::tellg(_QWORD, _QWORD); weak
// __int64 __fastcall std::ios_base::operator!(_QWORD); weak
// bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this); weak
// __int64 __fastcall std::streambuf::streambuf(_QWORD); weak
// int std::uncaught_exceptions(); weak
// void __noreturn std::_Xlength_error(const char *); weak
// __int64 __fastcall std::ostream::flush(_QWORD); weak
// __int64 __fastcall _std_exception_copy(_QWORD); weak
// __int64 __fastcall _std_exception_destroy(_QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *Process32NextW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern BOOL (__stdcall *Process32FirstW)(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HANDLE (__stdcall *CreateRemoteThread)(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *SetConsoleOutputCP)(UINT wCodePageID);
// extern BOOL (__stdcall *SetConsoleTitleW)(LPCWSTR lpConsoleTitle);
// extern BOOL (__stdcall *WriteProcessMemory)(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
// extern LPVOID (__stdcall *VirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern BOOL (__stdcall *ReadProcessMemory)(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead);
// extern BOOL (__stdcall *VirtualFreeEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// extern BOOL (__stdcall *K32EnumProcessModulesEx)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded, DWORD dwFilterFlag);
// extern DWORD (__stdcall *K32GetModuleFileNameExA)(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern BOOL (__stdcall *IsWow64Process)(HANDLE hProcess, PBOOL Wow64Process);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern int std::locale::id::_Id_cnt; weak
// extern _UNKNOWN std::codecvt<char,char,_Mbstatet>::id; weak
// extern int (__cdecl *getch)();
// extern void (__cdecl *lock_file)(FILE *Stream);
// extern void (__cdecl *unlock_file)(FILE *Stream);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern int (__cdecl *fputc)(int Character, FILE *Stream);
// extern errno_t (__cdecl *get_stream_buffer_pointers)(FILE *Stream, char ***Base, char ***Pointer, int **Count);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *fseeki64)(FILE *Stream, __int64 Offset, int Origin);
// extern size_t (__cdecl *fread)(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *fsetpos)(FILE *Stream, const fpos_t *Position);
// extern int (__cdecl *ungetc)(int Character, FILE *Stream);
// extern int (__cdecl *setvbuf)(FILE *Stream, char *Buffer, int Mode, size_t Size);
// extern int (__cdecl *fgetpos)(FILE *Stream, fpos_t *Position);
// extern size_t (__cdecl *fwrite)(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
// extern int (__cdecl *_stdio_common_vfprintf)(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *fgetc)(FILE *Stream);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern int (__cdecl *tolower)(int C);
// extern int (__cdecl *stricmp)(const char *String1, const char *String2);
_UNKNOWN unk_140010A50; // weak
void *type_info::`vftable' = &sub_14000BB7C; // weak
void *std::exception::`vftable' = &sub_140001100; // weak
void *std::bad_alloc::`vftable' = &sub_140001100; // weak
void *std::bad_array_new_length::`vftable' = &sub_140001100; // weak
void *std::ostringstream::`vftable' = &sub_1400029EC; // weak
void *std::stringbuf::`vftable' = &std::stringbuf::`scalar deleting destructor'; // weak
_UNKNOWN unk_140010C00; // weak
void *LuoInjector::InjectorException::`vftable' = &sub_140001A30; // weak
_UNKNOWN unk_140010D54; // weak
void *std::filebuf::`vftable' = &sub_140008700; // weak
void *std::bad_cast::`vftable' = &sub_140001100; // weak
_UNKNOWN unk_140011218; // weak
void *std::ifstream::`vftable' = &sub_140009024; // weak
void (*qword_140012078[2])(void) = { NULL, NULL }; // weak
void (*qword_140012088)(void) = NULL; // weak
int dword_140015008 = 1; // weak
int dword_14001500C = 2; // weak
__int64 qword_140015010 = 524288LL; // weak
__int64 qword_140015018 = 33554432LL; // weak
__int64 qword_140015020 = -1LL; // weak
uintptr_t _security_cookie = 47936899621426uLL;
__int64 qword_140015080 = -47936899621427LL; // weak
void *qword_140015098 = (void *)0x7942LL; // idb
__int64 qword_1400150A8 = 2LL; // weak
__int64 qword_1400150B0 = 15LL; // weak
void *aLoader[] = ; // idb
__int64 qword_1400150C8 = 6LL; // weak
__int64 qword_1400150D0 = 15LL; // weak
void *aYinyiDll[] = { (void *)0x6C642E69796E6959LL }; // idb
__int64 qword_1400150E8 = 9LL; // weak
__int64 qword_1400150F0 = 15LL; // weak
void *aLoad[] = ; // idb
__int64 qword_140015108 = 4LL; // weak
__int64 qword_140015110 = 15LL; // weak
void *qword_140015510 = NULL; // idb
int dword_140015568 = 0; // weak
int dword_14001556C = 0; // weak
union _SLIST_HEADER stru_140015580 = { { 0uLL, 0uLL } }; // weak
_UNKNOWN unk_140015590; // weak
_UNKNOWN unk_140015598; // weak
__int64 qword_1400155A0 = 0LL; // weak
char *Block = NULL; // idb
__int64 qword_1400155B8 = 0LL; // weak
__int64 qword_1400155C0 = 0LL; // weak
__int64 qword_1400155C8 = 0LL; // weak
_UNKNOWN unk_1400155D0; // weak
_UNKNOWN unk_1400155D8; // weak


//----- (0000000140001000) ----------------------------------------------------
int sub_140001000()
{
  sub_140005F50(&Block, "SSJJ_BattleClient_Unity.exe", 0x1Bu);
  return atexit(sub_14000D110);
}

//----- (0000000140001030) ----------------------------------------------------
int sub_140001030()
{
  return atexit(sub_14000D180);
}

//----- (0000000140001040) ----------------------------------------------------
int sub_140001040()
{
  return atexit(sub_14000D1F0);
}

//----- (0000000140001050) ----------------------------------------------------
int sub_140001050()
{
  return atexit(sub_14000D260);
}

//----- (0000000140001060) ----------------------------------------------------
int sub_140001060()
{
  return atexit(sub_14000D2D0);
}

//----- (000000014000106C) ----------------------------------------------------
int sub_14000106C()
{
  return atexit(sub_14000D33C);
}

//----- (0000000140001080) ----------------------------------------------------
__int64 __fastcall sub_140001080(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  return a1;
}
// 14000E290: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';

//----- (00000001400010E0) ----------------------------------------------------
const char *__fastcall sub_1400010E0(__int64 a1)
{
  const char *result; // rax

  result = "Unknown exception";
  if ( *(_QWORD *)(a1 + 8) )
    return *(const char **)(a1 + 8);
  return result;
}

//----- (0000000140001100) ----------------------------------------------------
char *__fastcall sub_140001100(char *Block, char a2)
{
  *(_QWORD *)Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 8);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14000E298: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';

//----- (0000000140001150) ----------------------------------------------------
_QWORD *__fastcall sub_140001150(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad array new length";
  *a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 140010AF8: using guessed type void *std::bad_array_new_length::`vftable';

//----- (0000000140001180) ----------------------------------------------------
void __noreturn sub_140001180()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140001150(pExceptionObject);
  throw (std::bad_array_new_length *)pExceptionObject;
}
// 140001180: using guessed type void __noreturn sub_140001180();

//----- (00000001400011A0) ----------------------------------------------------
__int64 __fastcall sub_1400011A0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_array_new_length::`vftable';
  return a1;
}
// 14000E290: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';
// 140010AF8: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00000001400011E0) ----------------------------------------------------
__int64 __fastcall sub_1400011E0(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 14000E290: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';
// 140010AD0: using guessed type void *std::bad_alloc::`vftable';

//----- (0000000140001220) ----------------------------------------------------
void __fastcall sub_140001220(_QWORD *a1, __int64 a2)
{
  _BYTE *v2; // rax
  _BYTE *v4; // rcx
  _BYTE *v5; // rdx
  char v6[8]; // [rsp+20h] [rbp-28h] BYREF
  __int64 v7; // [rsp+28h] [rbp-20h] BYREF

  v2 = (_BYTE *)a1[1];
  v4 = (_BYTE *)a1[2];
  v7 = a2;
  if ( a2 >= 128 )
  {
    v6[0] = 104;
    if ( v2 == v4 )
    {
      sub_1400015A0(a1, v2, v6);
    }
    else
    {
      *v2 = 104;
      ++a1[1];
    }
    sub_140001370((__int64)a1, (_BYTE *)a1[1], &v7, 4u);
  }
  else
  {
    v6[0] = 106;
    if ( v2 == v4 )
    {
      sub_1400015A0(a1, v2, v6);
    }
    else
    {
      *v2 = 106;
      ++a1[1];
    }
    v5 = (_BYTE *)a1[1];
    v6[0] = v7;
    if ( v5 == (_BYTE *)a1[2] )
    {
      sub_1400015A0(a1, v5, v6);
    }
    else
    {
      *v5 = v7;
      ++a1[1];
    }
  }
}

//----- (0000000140001370) ----------------------------------------------------
void __fastcall sub_140001370(__int64 a1, _BYTE *a2, const void *a3, size_t a4)
{
  _BYTE *v8; // rbp
  __int64 v9; // rcx
  _BYTE *v10; // r13
  char *v11; // r12
  size_t v12; // rdi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdx
  size_t v15; // rcx
  void *v16; // rax
  char *v17; // rsi
  size_t v18; // r8
  const void *v19; // rdx
  char *v20; // rcx
  _BYTE *v21; // rax
  _BYTE *v22; // rcx
  signed __int64 v23; // rsi
  char *v24; // rdi
  char *v25; // rdi
  size_t Size; // [rsp+28h] [rbp-50h]
  char *v28; // [rsp+30h] [rbp-48h]

  if ( !a4 )
    return;
  v8 = *(_BYTE **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if ( a4 <= v9 - (__int64)v8 )
  {
    v23 = v8 - a2;
    if ( a4 >= v8 - a2 )
    {
      v25 = &a2[a4];
      memmove(&a2[a4], a2, v8 - a2);
      *(_QWORD *)(a1 + 8) = &v25[v23];
    }
    else
    {
      v24 = &v8[-a4];
      memmove(v8, &v8[-a4], a4);
      *(_QWORD *)(a1 + 8) = &v8[a4];
      memmove(&v8[-(v24 - a2)], a2, v24 - a2);
    }
    memmove(a2, a3, a4);
    return;
  }
  v10 = *(_BYTE **)a1;
  v11 = &v8[-*(_QWORD *)a1];
  v12 = 0x7FFFFFFFFFFFFFFFLL;
  if ( a4 > 0x7FFFFFFFFFFFFFFFLL - (__int64)v11 )
    sub_140001720(v9);
  v28 = &v11[a4];
  v13 = v9 - (_QWORD)v10;
  v14 = v13 >> 1;
  if ( v13 > 0x7FFFFFFFFFFFFFFFLL - (v13 >> 1) )
  {
    v15 = 0x8000000000000026uLL;
LABEL_6:
    v16 = operator new(v15);
    if ( !v16 )
      goto LABEL_23;
    v17 = (char *)(((unsigned __int64)v16 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *((_QWORD *)v17 - 1) = v16;
    goto LABEL_16;
  }
  v12 = (size_t)&v11[a4];
  if ( v13 + v14 >= (unsigned __int64)&v11[a4] )
    v12 = v13 + v14;
  if ( v12 )
  {
    if ( v12 >= 0x1000 )
    {
      v15 = v12 + 39;
      if ( v12 + 39 < v12 )
        sub_140001180(v15);
      goto LABEL_6;
    }
    v17 = (char *)operator new(v12);
  }
  else
  {
    v17 = 0;
  }
LABEL_16:
  Size = a2 - v10;
  memmove(&v17[a2 - v10], a3, a4);
  if ( a4 == 1 && a2 == v8 )
  {
    v18 = (size_t)v11;
    v19 = v10;
    v20 = v17;
  }
  else
  {
    memmove(v17, v10, Size);
    v20 = &v17[Size + a4];
    v18 = v8 - a2;
    v19 = a2;
  }
  memmove(v20, v19, v18);
  v21 = *(_BYTE **)a1;
  if ( *(_QWORD *)a1 )
  {
    if ( *(_QWORD *)(a1 + 16) - (_QWORD)v21 < 0x1000u )
    {
      v22 = *(_BYTE **)a1;
    }
    else
    {
      v22 = (_BYTE *)*((_QWORD *)v21 - 1);
      if ( (unsigned __int64)(v21 - v22 - 8) > 0x1F )
LABEL_23:
        __fastfail(5u);
    }
    j_j_free(v22);
  }
  *(_QWORD *)a1 = v17;
  *(_QWORD *)(a1 + 8) = &v28[(_QWORD)v17];
  *(_QWORD *)(a1 + 16) = &v17[v12];
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (00000001400015A0) ----------------------------------------------------
_BYTE *__fastcall sub_1400015A0(_QWORD *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // r14
  size_t v4; // rbx
  __int64 v6; // rax
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // r15
  unsigned __int64 v11; // rdx
  size_t v12; // rcx
  void *v13; // rax
  _QWORD *v14; // rdi
  _BYTE *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t v19; // r8
  _BYTE *v20; // rax
  _BYTE *v21; // rcx

  v3 = (_BYTE *)*a1;
  v4 = 0x7FFFFFFFFFFFFFFFLL;
  v6 = a1[1] - *a1;
  if ( v6 == 0x7FFFFFFFFFFFFFFFLL )
    sub_140001720(a1);
  v9 = a1[2] - (_QWORD)v3;
  v10 = v6 + 1;
  v11 = v9 >> 1;
  if ( v9 <= 0x7FFFFFFFFFFFFFFFLL - (v9 >> 1) )
  {
    v4 = v6 + 1;
    if ( v9 + v11 >= v10 )
      v4 = v9 + v11;
    if ( !v4 )
    {
      v14 = 0;
      goto LABEL_14;
    }
    if ( v4 < 0x1000 )
    {
      v14 = operator new(v4);
      goto LABEL_14;
    }
    v12 = v4 + 39;
    if ( v4 + 39 < v4 )
      sub_140001180(v12);
  }
  else
  {
    v12 = 0x8000000000000026uLL;
  }
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_20;
  v14 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v14 - 1) = v13;
LABEL_14:
  v15 = (char *)v14 + a2 - v3;
  *v15 = *a3;
  v16 = v14;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    v19 = v17 - v18;
  }
  else
  {
    memmove(v14, v18, a2 - v18);
    v16 = v15 + 1;
    v19 = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, v19);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( a1[2] - (_QWORD)v20 < 0x1000u )
    {
      v21 = (_BYTE *)*a1;
    }
    else
    {
      v21 = (_BYTE *)*((_QWORD *)v20 - 1);
      if ( (unsigned __int64)(v20 - v21 - 8) > 0x1F )
LABEL_20:
        __fastfail(5u);
    }
    j_j_free(v21);
  }
  *a1 = v14;
  a1[1] = (char *)v14 + v10;
  a1[2] = (char *)v14 + v4;
  return v15;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (0000000140001720) ----------------------------------------------------
void __noreturn sub_140001720()
{
  std::_Xlength_error("vector too long");
}
// 140001720: using guessed type void __noreturn sub_140001720();
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140001740) ----------------------------------------------------
void __noreturn sub_140001740()
{
  std::_Xlength_error("string too long");
}
// 140001740: using guessed type void __noreturn sub_140001740();
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140001760) ----------------------------------------------------
// Hidden C++ exception states: #wind=6
__int64 __fastcall sub_140001760(__int64 a1, __int64 a2, unsigned int a3)
{
  _QWORD *v4; // rsi
  __int64 v6; // rbx
  unsigned __int64 v7; // r8
  __int64 *v8; // rax
  __int64 *v9; // rax
  __int64 *v10; // rax
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // r8
  const void *v13; // rdx
  size_t v14; // r8
  unsigned __int64 v15; // rdx
  char *v16; // rax
  char *v17; // rcx
  void *v18; // rcx
  void *Block[2]; // [rsp+28h] [rbp-D8h] BYREF
  __int128 v21; // [rsp+38h] [rbp-C8h]
  __int64 v22; // [rsp+50h] [rbp-B0h]
  int v23; // [rsp+7Ch] [rbp-84h]
  __int64 v24[30]; // [rsp+80h] [rbp-80h] BYREF

  v4 = (_QWORD *)a2;
  v22 = a1;
  *(_OWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &LuoInjector::InjectorException::`vftable';
  v6 = a1 + 24;
  sub_140001E00(a1 + 24, a2);
  *(_DWORD *)(a1 + 56) = a3;
  if ( !a3 )
    return a1;
  memset(v24, 0, 0xE8u);
  v24[0] = (__int64)&unk_140010C00;
  std::ios::ios(&v24[17]);
  std::ostream::ostream(v24, &v24[1], 0, 0, 1);
  *(__int64 *)((char *)v24 + *(int *)(v24[0] + 4)) = (__int64)&std::ostringstream::`vftable';
  *(int *)((char *)&v23 + *(int *)(v24[0] + 4)) = *(_DWORD *)(v24[0] + 4) - 136;
  std::streambuf::streambuf(&v24[1]);
  v24[1] = (__int64)&std::stringbuf::`vftable';
  v24[14] = 0;
  LODWORD(v24[15]) = 4;
  v7 = v4[2];
  if ( v4[3] > 0xFu )
    v4 = (_QWORD *)*v4;
  v8 = sub_140002650(v24, (__int64)v4, v7);
  v9 = sub_140001BC0(v8, " (Error Code: ");
  v10 = (__int64 *)std::ostream::operator<<(v9, a3);
  sub_140001BC0(v10, ")");
  *(_OWORD *)Block = 0;
  *(_QWORD *)&v21 = 0;
  v11 = 15;
  *((_QWORD *)&v21 + 1) = 15;
  LOBYTE(Block[0]) = 0;
  if ( (v24[15] & 0x22) != 2 )
  {
    v12 = *(_QWORD *)v24[9];
    if ( *(_QWORD *)v24[9] )
    {
      v13 = *(const void **)v24[5];
      if ( v12 < v24[14] )
        v12 = v24[14];
      v14 = v12 - (_QWORD)v13;
      goto LABEL_12;
    }
  }
  if ( (v24[15] & 4) == 0 && *(_QWORD *)v24[8] )
  {
    v13 = *(const void **)v24[4];
    v14 = *(_QWORD *)v24[8] + *(int *)v24[11] - *(_QWORD *)v24[4];
LABEL_12:
    if ( v13 )
    {
      sub_140002890(Block, v13, v14);
      v11 = *((_QWORD *)&v21 + 1);
    }
  }
  if ( (void **)v6 != Block )
  {
    v15 = *(_QWORD *)(v6 + 24);
    if ( v15 > 0xF )
    {
      v16 = *(char **)v6;
      if ( v15 + 1 < 0x1000 )
      {
        v17 = *(char **)v6;
      }
      else
      {
        v17 = (char *)*((_QWORD *)v16 - 1);
        if ( (unsigned __int64)(v16 - v17 - 8) > 0x1F )
          goto LABEL_25;
      }
      j_j_free(v17);
    }
    *(_OWORD *)v6 = *(_OWORD *)Block;
    *(_OWORD *)(v6 + 16) = v21;
    v11 = 15;
    LOBYTE(Block[0]) = 0;
  }
  if ( v11 > 0xF )
  {
    if ( v11 + 1 < 0x1000 )
    {
      v18 = Block[0];
    }
    else
    {
      v18 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v18 - 8) > 0x1F )
LABEL_25:
        __fastfail(5u);
    }
    j_j_free(v18);
  }
  *(__int64 *)((char *)v24 + *(int *)(v24[0] + 4)) = (__int64)&std::ostringstream::`vftable';
  *(int *)((char *)&v23 + *(int *)(v24[0] + 4)) = *(_DWORD *)(v24[0] + 4) - 136;
  sub_1400024B0((__int64)&v24[1]);
  std::ostream::~ostream<char,std::char_traits<char>>(&v24[2]);
  std::ios::~ios<char,std::char_traits<char>>(&v24[17]);
  return a1;
}
// 14000E0E8: using guessed type __int64 __fastcall std::ios::ios(_QWORD);
// 14000E100: using guessed type __int64 __fastcall std::ostream::ostream(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 14000E108: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14000E160: using guessed type __int64 __fastcall std::ostream::~ostream<char,std::char_traits<char>>(_QWORD);
// 14000E168: using guessed type __int64 __fastcall std::ostream::operator<<(_QWORD, _QWORD);
// 14000E220: using guessed type __int64 __fastcall std::streambuf::streambuf(_QWORD);
// 140010B78: using guessed type void *std::ostringstream::`vftable';
// 140010B88: using guessed type void *std::stringbuf::`vftable';
// 140010C10: using guessed type void *LuoInjector::InjectorException::`vftable';

//----- (0000000140001A30) ----------------------------------------------------
_QWORD *__fastcall sub_140001A30(_QWORD *Block, char a2)
{
  unsigned __int64 v4; // rdx
  __int64 v5; // rax
  void *v6; // rcx

  v4 = Block[6];
  if ( v4 > 0xF )
  {
    v5 = Block[3];
    if ( v4 + 1 < 0x1000 )
    {
      v6 = (void *)Block[3];
    }
    else
    {
      v6 = *(void **)(v5 - 8);
      if ( (unsigned __int64)(v5 - (_QWORD)v6 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v6);
  }
  Block[5] = 0;
  Block[6] = 15;
  *((_BYTE *)Block + 24) = 0;
  *Block = &std::exception::`vftable';
  _std_exception_destroy(Block + 1);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}
// 14000E298: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';

//----- (0000000140001AD0) ----------------------------------------------------
__int64 __fastcall sub_140001AD0(_QWORD *a1)
{
  unsigned __int64 v1; // rdx
  __int64 v3; // rax
  void *v4; // rcx

  v1 = a1[6];
  if ( v1 > 0xF )
  {
    v3 = a1[3];
    if ( v1 + 1 < 0x1000 )
    {
      v4 = (void *)a1[3];
    }
    else
    {
      v4 = *(void **)(v3 - 8);
      if ( (unsigned __int64)(v3 - (_QWORD)v4 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
  }
  a1[5] = 0;
  a1[6] = 15;
  *((_BYTE *)a1 + 24) = 0;
  *a1 = &std::exception::`vftable';
  return _std_exception_destroy(a1 + 1);
}
// 14000E298: using guessed type __int64 __fastcall _std_exception_destroy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';

//----- (0000000140001BB0) ----------------------------------------------------
__int64 __fastcall sub_140001BB0(__int64 a1)
{
  __int64 result; // rax

  result = a1 + 24;
  if ( *(_QWORD *)(a1 + 48) > 0xFu )
    return *(_QWORD *)result;
  return result;
}

//----- (0000000140001BC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
__int64 *__fastcall sub_140001BC0(__int64 *a1, const char *a2)
{
  __int64 *v3; // rsi
  unsigned int v4; // ebx
  signed __int64 v5; // rax
  signed __int64 v6; // r15
  __int64 v7; // r9
  __int64 v8; // rdi
  __int64 v9; // rdi
  __int64 *v10; // r14
  __int64 v11; // rcx
  bool v12; // al
  __int64 *v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // r8
  __int64 v16; // rcx
  __int64 *v18; // [rsp+20h] [rbp-38h]
  int v20; // [rsp+70h] [rbp+18h]

  v3 = a1;
  v4 = 0;
  v20 = 0;
  v5 = strlen(a2);
  v6 = v5;
  v7 = *(int *)(*v3 + 4);
  v8 = *(__int64 *)((char *)v3 + v7 + 40);
  if ( v8 <= 0 || v8 <= v5 )
    v9 = 0;
  else
    v9 = v8 - v5;
  v10 = v3;
  v18 = v3;
  v11 = *(__int64 *)((char *)v3 + v7 + 72);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  v12 = std::ios_base::good((std::ios_base *)((char *)v3 + *(int *)(*v3 + 4)));
  if ( v12 )
  {
    v13 = *(__int64 **)((char *)v3 + *(int *)(*v3 + 4) + 80);
    if ( !v13 || v13 == v3 )
    {
      v12 = 1;
    }
    else
    {
      std::ostream::flush();
      v12 = std::ios_base::good((std::ios_base *)((char *)v3 + *(int *)(*v3 + 4)));
    }
  }
  if ( v12 )
  {
    try
    {
      v14 = *v3;
      if ( (*(_DWORD *)((_BYTE *)v3 + *(int *)(*v3 + 4) + 24) & 0x1C0) != 0x40 )
      {
        while ( v9 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 72),
                               *((unsigned __int8 *)v3 + *(int *)(*v3 + 4) + 88)) == -1 )
            goto LABEL_23;
          --v9;
        }
        v14 = *v3;
      }
      if ( std::streambuf::sputn(*(__int64 *)((char *)v3 + *(int *)(v14 + 4) + 72), a2, v6) == v6 )
      {
        while ( v9 > 0 )
        {
          if ( (unsigned int)std::streambuf::sputc(
                               *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 72),
                               *((unsigned __int8 *)v3 + *(int *)(*v3 + 4) + 88)) == -1 )
            goto LABEL_23;
          --v9;
        }
      }
      else
      {
LABEL_23:
        v4 = 4;
        v20 = 4;
      }
      *(__int64 *)((char *)v3 + *(int *)(*v3 + 4) + 40) = 0;
    }
    catch ( ... )
    {
      LOBYTE(v15) = 1;
      std::ios::setstate((char *)a1 + *(int *)(*a1 + 4), 4, v15);
      v3 = a1;
      v4 = v20;
      v10 = v18;
    }
  }
  else
  {
    v4 = 4;
  }
  std::ios::setstate((char *)v3 + *(int *)(*v3 + 4), v4, 0);
  if ( !std::uncaught_exceptions() )
    std::ostream::_Osfx(v10);
  v16 = *(__int64 *)((char *)v10 + *(int *)(*v10 + 4) + 72);
  if ( v16 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16LL))(v16);
  return v3;
}
// 14000C92B: variable 'v15' is possibly undefined
// 14000E0E0: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14000E0F0: using guessed type __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD);
// 14000E0F8: using guessed type __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD);
// 14000E120: using guessed type __int64 __fastcall std::ostream::_Osfx(_QWORD);
// 14000E170: using guessed type bool std::ios_base::good(std::ios_base *__hidden this);
// 14000E228: using guessed type int std::uncaught_exceptions();
// 14000E238: using guessed type __int64 std::ostream::flush(void);

//----- (0000000140001E00) ----------------------------------------------------
__int64 __fastcall sub_140001E00(__int64 a1, __int64 a2)
{
  _OWORD *v2; // r14
  unsigned __int64 v4; // rsi
  __int64 v5; // rdi
  size_t v7; // rax
  void *v8; // rax
  void *v9; // rcx
  size_t v10; // rcx
  _QWORD *v11; // rax

  v2 = (_OWORD *)a2;
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  if ( *(_QWORD *)(a2 + 24) > 0xFu )
    v2 = *(_OWORD **)a2;
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001740();
  if ( v4 <= 0xF )
  {
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = 15;
    *(_OWORD *)a1 = *v2;
    return a1;
  }
  if ( (v4 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v7 = 0x8000000000000027uLL;
LABEL_8:
    v8 = operator new(v7);
    v9 = v8;
    if ( !v8 )
      __fastfail(5u);
    v11 = (_QWORD *)(((unsigned __int64)v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v9;
    goto LABEL_19;
  }
  v5 = v4 | 0xF;
  if ( (v4 | 0xF) < 0x16 )
    v5 = 22;
  v10 = v5 + 1;
  if ( v5 == -1 )
  {
    v11 = 0;
  }
  else
  {
    if ( v10 >= 0x1000 )
    {
      v7 = v5 + 40;
      if ( v5 + 40 < (unsigned __int64)(v5 + 1) )
        sub_140001180();
      goto LABEL_8;
    }
    v11 = operator new(v10);
  }
LABEL_19:
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + 16) = v4;
  *(_QWORD *)(a1 + 24) = v5;
  memcpy(v11, v2, v4 + 1);
  return a1;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140001F20) ----------------------------------------------------
unsigned __int64 *__fastcall sub_140001F20(__int64 a1, unsigned __int64 *a2, _QWORD *a3, char a4)
{
  int v6; // esi
  bool v7; // cl
  int v8; // r9d
  bool v9; // al
  unsigned __int64 v10; // rbx
  __int64 *v11; // r15
  __int64 v12; // r8
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // r14
  __int64 v16; // rdi
  int v17; // r8d

  v6 = a4 & 1;
  v7 = (a4 & 1) != 0 && (*(_BYTE *)(a1 + 112) & 4) != 0;
  v8 = a4 & 2;
  v9 = v8 && (*(_BYTE *)(a1 + 112) & 2) != 0;
  if ( v7 || v9 )
    goto LABEL_29;
  v10 = *a3 + a3[1];
  v11 = *(__int64 **)(a1 + 56);
  v12 = *v11;
  if ( (*(_BYTE *)(a1 + 112) & 2) != 0 )
  {
    v13 = 0;
  }
  else
  {
    v13 = **(_QWORD **)(a1 + 64);
    if ( v13 && *(_QWORD *)(a1 + 104) < v13 )
      *(_QWORD *)(a1 + 104) = v13;
  }
  v14 = *(_QWORD *)(a1 + 104);
  v15 = **(_QWORD **)(a1 + 24);
  if ( v10 > v14 - v15 || v10 && (v6 && !v12 || v8 && !v13) )
  {
LABEL_29:
    *a2 = -1;
  }
  else
  {
    v16 = v15 + v10;
    if ( v6 && v12 )
    {
      *v11 = v16;
      **(_DWORD **)(a1 + 80) = v14 - v16;
    }
    if ( v8 && v13 )
    {
      v17 = **(_DWORD **)(a1 + 64) + **(_DWORD **)(a1 + 88) - v16;
      **(_QWORD **)(a1 + 32) = v15;
      **(_QWORD **)(a1 + 64) = v16;
      **(_DWORD **)(a1 + 88) = v17;
    }
    *a2 = v10;
  }
  a2[1] = 0;
  a2[2] = 0;
  return a2;
}

//----- (0000000140002050) ----------------------------------------------------
_QWORD *__fastcall sub_140002050(__int64 a1, _QWORD *a2, __int64 a3, int a4, char a5)
{
  bool v7; // dl
  bool v8; // cl
  __int64 *v9; // r15
  __int64 v10; // rdx
  unsigned __int64 v11; // rcx
  __int64 *v12; // rax
  __int64 v13; // r14
  __int64 v14; // rdi
  unsigned __int64 v15; // rsi
  int v16; // r9d
  __int64 v17; // rax
  __int64 v18; // r9
  __int64 v19; // rbx
  int v20; // r8d

  v7 = (a5 & 1) != 0 && (*(_BYTE *)(a1 + 112) & 4) != 0;
  v8 = (a5 & 2) != 0 && (*(_BYTE *)(a1 + 112) & 2) != 0;
  if ( v7 || v8 )
    goto LABEL_43;
  v9 = *(__int64 **)(a1 + 56);
  v10 = *v9;
  if ( (*(_BYTE *)(a1 + 112) & 2) != 0 )
  {
    v11 = 0;
  }
  else
  {
    v11 = **(_QWORD **)(a1 + 64);
    if ( v11 && *(_QWORD *)(a1 + 104) < v11 )
      *(_QWORD *)(a1 + 104) = v11;
  }
  v12 = *(__int64 **)(a1 + 24);
  v13 = *(_QWORD *)(a1 + 104);
  v14 = *v12;
  v15 = v13 - *v12;
  if ( !a4 )
  {
    v17 = 0;
    goto LABEL_30;
  }
  v16 = a4 - 1;
  if ( !v16 )
  {
    if ( (a5 & 3) != 3 )
    {
      if ( (a5 & 1) != 0 )
      {
        if ( v10 || !v14 )
        {
          v17 = v10 - v14;
          goto LABEL_30;
        }
      }
      else if ( (a5 & 2) != 0 && (v11 || !v14) )
      {
        v17 = v11 - v14;
        goto LABEL_30;
      }
    }
LABEL_43:
    *a2 = -1;
    goto LABEL_44;
  }
  if ( v16 != 1 )
    goto LABEL_43;
  v17 = *(_QWORD *)(a1 + 104) - *v12;
LABEL_30:
  v18 = v17 + a3;
  if ( v17 + a3 > v15 || v18 && ((a5 & 1) != 0 && !v10 || (a5 & 2) != 0 && !v11) )
    goto LABEL_43;
  v19 = v18 + v14;
  if ( (a5 & 1) != 0 && v10 )
  {
    *v9 = v19;
    **(_DWORD **)(a1 + 80) = v13 - v19;
  }
  if ( (a5 & 2) != 0 && v11 )
  {
    v20 = **(_DWORD **)(a1 + 64) + **(_DWORD **)(a1 + 88) - v19;
    **(_QWORD **)(a1 + 32) = v14;
    **(_QWORD **)(a1 + 64) = v19;
    **(_DWORD **)(a1 + 88) = v20;
  }
  *a2 = v18;
LABEL_44:
  a2[1] = 0;
  a2[2] = 0;
  return a2;
}

//----- (00000001400021F0) ----------------------------------------------------
__int64 __fastcall sub_1400021F0(__int64 a1)
{
  unsigned __int8 **v1; // r10
  unsigned __int8 *v2; // rdx
  int *v3; // r9
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rax

  v1 = *(unsigned __int8 ***)(a1 + 56);
  v2 = *v1;
  if ( !*v1 )
    return 0xFFFFFFFFLL;
  v3 = *(int **)(a1 + 80);
  if ( v2 < &v2[*v3] )
    return *v2;
  v5 = **(_QWORD **)(a1 + 64);
  if ( !v5 || (*(_BYTE *)(a1 + 112) & 4) != 0 )
    return 0xFFFFFFFFLL;
  v6 = *(_QWORD *)(a1 + 104);
  if ( v6 < v5 )
    v6 = **(_QWORD **)(a1 + 64);
  if ( v6 <= (unsigned __int64)v2 )
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 104) = v6;
  *v3 = v6 - *(_DWORD *)v1;
  return ***(unsigned __int8 ***)(a1 + 56);
}

//----- (0000000140002250) ----------------------------------------------------
__int64 __fastcall sub_140002250(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // r8

  v2 = **(_QWORD **)(a1 + 56);
  if ( !v2
    || v2 <= **(_QWORD **)(a1 + 24)
    || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && (*(_BYTE *)(a1 + 112) & 2) != 0 )
  {
    return 0xFFFFFFFFLL;
  }
  ++**(_DWORD **)(a1 + 80);
  --**(_QWORD **)(a1 + 56);
  if ( a2 == -1 )
    return 0;
  else
    ***(_BYTE ***)(a1 + 56) = a2;
  return a2;
}

//----- (00000001400022B0) ----------------------------------------------------
__int64 __fastcall sub_1400022B0(__int64 a1, unsigned int a2)
{
  unsigned __int64 v5; // r8
  int *v6; // rcx
  __int64 v7; // rdx
  _QWORD *v8; // rcx
  _BYTE *v9; // rdx
  _QWORD **v10; // r14
  const void *v11; // rsi
  size_t v12; // rdi
  size_t v13; // rbp
  _QWORD *v14; // r15
  size_t v15; // rcx
  void *v16; // rax
  char *v17; // rdx
  int v18; // r8d
  _BYTE *v19; // rcx
  _DWORD *v20; // rax
  _QWORD *v21; // rcx
  _BYTE *v22; // rdx

  if ( (*(_BYTE *)(a1 + 112) & 2) != 0 )
    return 0xFFFFFFFFLL;
  if ( a2 == -1 )
    return 0;
  v5 = **(_QWORD **)(a1 + 64);
  if ( !v5 )
  {
    v10 = (_QWORD **)(a1 + 24);
    v12 = 0;
    v11 = **(const void ***)(a1 + 24);
LABEL_19:
    v13 = 32;
    goto LABEL_20;
  }
  v6 = *(int **)(a1 + 88);
  v7 = *v6;
  if ( v5 < v5 + v7 )
  {
    *v6 = v7 - 1;
    v8 = *(_QWORD **)(a1 + 64);
    v9 = (_BYTE *)(*v8)++;
    *v9 = a2;
    *(_QWORD *)(a1 + 104) = v5 + 1;
    return a2;
  }
  v10 = (_QWORD **)(a1 + 24);
  v11 = **(const void ***)(a1 + 24);
  v12 = v5 + v7 - (_QWORD)v11;
  if ( v12 < 0x20 )
    goto LABEL_19;
  if ( v12 >= 0x3FFFFFFF )
  {
    LODWORD(v13) = 0x7FFFFFFF;
    if ( v12 < 0x7FFFFFFF )
    {
      v15 = 2147483686LL;
LABEL_16:
      v16 = operator new(v15);
      if ( !v16 )
        goto LABEL_27;
      v14 = (_QWORD *)(((unsigned __int64)v16 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v14 - 1) = v16;
      goto LABEL_21;
    }
    return 0xFFFFFFFFLL;
  }
  v13 = 2 * v12;
  if ( 2 * v12 )
  {
    if ( v13 >= 0x1000 )
    {
      v15 = v13 + 39;
      if ( v13 + 39 < v13 )
        sub_140001180();
      goto LABEL_16;
    }
LABEL_20:
    v14 = operator new(v13);
    goto LABEL_21;
  }
  v14 = 0;
LABEL_21:
  memcpy(v14, v11, v12);
  *(_QWORD *)(a1 + 104) = (char *)v14 + v12 + 1;
  **(_QWORD **)(a1 + 32) = v14;
  **(_QWORD **)(a1 + 64) = (char *)v14 + v12;
  **(_DWORD **)(a1 + 88) = v13 - v12;
  if ( (*(_BYTE *)(a1 + 112) & 4) != 0 )
  {
    **v10 = v14;
    **(_QWORD **)(a1 + 56) = v14;
    **(_DWORD **)(a1 + 80) = 0;
  }
  else
  {
    v17 = (char *)v14 + **(_QWORD **)(a1 + 56) - (_QWORD)v11;
    v18 = *(_QWORD *)(a1 + 104) - (_DWORD)v17;
    **v10 = v14;
    **(_QWORD **)(a1 + 56) = v17;
    **(_DWORD **)(a1 + 80) = v18;
  }
  if ( (*(_BYTE *)(a1 + 112) & 1) != 0 )
  {
    if ( v12 < 0x1000 )
    {
      v19 = v11;
    }
    else
    {
      v19 = (_BYTE *)*((_QWORD *)v11 - 1);
      if ( (unsigned __int64)((_BYTE *)v11 - v19 - 8) > 0x1F )
LABEL_27:
        __fastfail(5u);
    }
    j_j_free(v19);
  }
  v20 = *(_DWORD **)(a1 + 88);
  *(_DWORD *)(a1 + 112) |= 1u;
  --*v20;
  v21 = *(_QWORD **)(a1 + 64);
  v22 = (_BYTE *)(*v21)++;
  *v22 = a2;
  return a2;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);

//----- (00000001400024B0) ----------------------------------------------------
__int64 __fastcall sub_1400024B0(__int64 a1)
{
  bool v1; // zf
  __int64 v3; // rcx
  __int64 v4; // rdx
  char **v5; // rax
  char *v6; // rcx
  char *v7; // rax

  v1 = (*(_BYTE *)(a1 + 112) & 1) == 0;
  *(_QWORD *)a1 = &std::stringbuf::`vftable';
  if ( !v1 )
  {
    v3 = **(_QWORD **)(a1 + 64);
    if ( v3 )
      v4 = v3 + **(int **)(a1 + 88);
    else
      v4 = **(_QWORD **)(a1 + 56) + **(int **)(a1 + 80);
    v5 = *(char ***)(a1 + 24);
    v6 = *v5;
    if ( (unsigned __int64)(v4 - (_QWORD)*v5) < 0x1000 )
    {
      v7 = *v5;
    }
    else
    {
      v7 = (char *)*((_QWORD *)v6 - 1);
      if ( (unsigned __int64)(v6 - v7 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v7);
  }
  **(_QWORD **)(a1 + 24) = 0;
  **(_QWORD **)(a1 + 56) = 0;
  **(_DWORD **)(a1 + 80) = 0;
  **(_QWORD **)(a1 + 32) = 0;
  **(_QWORD **)(a1 + 64) = 0;
  **(_DWORD **)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 112) &= ~1u;
  *(_QWORD *)(a1 + 104) = 0;
  return std::streambuf::~streambuf<char,std::char_traits<char>>(a1);
}
// 14000E110: using guessed type __int64 __fastcall std::streambuf::~streambuf<char,std::char_traits<char>>(_QWORD);
// 140010B88: using guessed type void *std::stringbuf::`vftable';

//----- (0000000140002580) ----------------------------------------------------
void *__fastcall sub_140002580(__int64 a1, char a2)
{
  void *v2; // rsi
  __int64 v5; // r8

  v2 = (void *)(a1 - 136);
  *(_QWORD *)(*(int *)(*(_QWORD *)(a1 - 136) + 4LL) + a1 - 136) = &std::ostringstream::`vftable';
  v5 = *(int *)(*(_QWORD *)(a1 - 136) + 4LL);
  *(_DWORD *)(v5 + a1 - 140) = v5 - 136;
  sub_1400024B0(a1 - 136 + 8);
  std::ostream::~ostream<char,std::char_traits<char>>(a1 - 120);
  std::ios::~ios<char,std::char_traits<char>>(a1);
  if ( (a2 & 1) != 0 )
    j_j_free(v2);
  return v2;
}
// 14000E108: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14000E160: using guessed type __int64 __fastcall std::ostream::~ostream<char,std::char_traits<char>>(_QWORD);
// 140010B78: using guessed type void *std::ostringstream::`vftable';

//----- (0000000140002650) ----------------------------------------------------
// Hidden C++ exception states: #wind=3 #try_helpers=1
__int64 *__fastcall sub_140002650(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  unsigned int v6; // ebx
  __int64 v7; // r9
  __int64 v8; // rdi
  unsigned __int64 v9; // rdi
  __int64 v11; // rcx
  bool v12; // al
  __int64 *v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx

  v6 = 0;
  v7 = *(int *)(*a1 + 4);
  v8 = *(__int64 *)((char *)a1 + v7 + 40);
  if ( v8 <= 0 || v8 <= a3 )
    v9 = 0;
  else
    v9 = v8 - a3;
  v11 = *(__int64 *)((char *)a1 + v7 + 72);
  if ( v11 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v11 + 8LL))(v11);
  v12 = std::ios_base::good((std::ios_base *)((char *)a1 + *(int *)(*a1 + 4)));
  if ( v12 )
  {
    v13 = *(__int64 **)((char *)a1 + *(int *)(*a1 + 4) + 80);
    if ( !v13 || v13 == a1 )
    {
      v12 = 1;
    }
    else
    {
      std::ostream::flush(v13);
      v12 = std::ios_base::good((std::ios_base *)((char *)a1 + *(int *)(*a1 + 4)));
    }
  }
  if ( v12 )
  {
    v14 = *a1;
    if ( (*(_DWORD *)((_BYTE *)a1 + *(int *)(*a1 + 4) + 24) & 0x1C0) != 0x40 )
    {
      while ( v9 )
      {
        if ( (unsigned int)std::streambuf::sputc(
                             *(__int64 *)((char *)a1 + *(int *)(*a1 + 4) + 72),
                             *((unsigned __int8 *)a1 + *(int *)(*a1 + 4) + 88)) == -1 )
        {
          v6 = 4;
          goto LABEL_18;
        }
        --v9;
      }
      v14 = *a1;
    }
    if ( std::streambuf::sputn(*(__int64 *)((char *)a1 + *(int *)(v14 + 4) + 72), a2, a3) == a3 )
    {
LABEL_18:
      while ( v9 )
      {
        if ( (unsigned int)std::streambuf::sputc(
                             *(__int64 *)((char *)a1 + *(int *)(*a1 + 4) + 72),
                             *((unsigned __int8 *)a1 + *(int *)(*a1 + 4) + 88)) == -1 )
        {
          v6 |= 4u;
          break;
        }
        --v9;
      }
    }
    else
    {
      v6 = 4;
    }
    *(__int64 *)((char *)a1 + *(int *)(*a1 + 4) + 40) = 0;
  }
  else
  {
    v6 = 4;
  }
  std::ios::setstate((char *)a1 + *(int *)(*a1 + 4), v6, 0);
  if ( !std::uncaught_exceptions() )
    std::ostream::_Osfx(a1);
  v15 = *(__int64 *)((char *)a1 + *(int *)(*a1 + 4) + 72);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16LL))(v15);
  return a1;
}
// 14000E0E0: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14000E0F0: using guessed type __int64 __fastcall std::streambuf::sputc(_QWORD, _QWORD);
// 14000E0F8: using guessed type __int64 __fastcall std::streambuf::sputn(_QWORD, _QWORD, _QWORD);
// 14000E120: using guessed type __int64 __fastcall std::ostream::_Osfx(_QWORD);
// 14000E170: using guessed type bool std::ios_base::good(std::ios_base *__hidden this);
// 14000E228: using guessed type int std::uncaught_exceptions();
// 14000E238: using guessed type __int64 __fastcall std::ostream::flush(_QWORD);

//----- (0000000140002890) ----------------------------------------------------
void **__fastcall sub_140002890(void **a1, const void *a2, size_t a3)
{
  unsigned __int64 v3; // rbp
  void *v7; // rdi
  __int64 v9; // rdi
  __int64 v10; // rdx
  _QWORD *v11; // r14
  size_t v12; // rcx
  void *v13; // rax
  char *v14; // rcx
  char *v15; // rax

  v3 = (unsigned __int64)a1[3];
  if ( a3 > v3 )
  {
    v9 = 0x7FFFFFFFFFFFFFFFLL;
    if ( a3 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001740();
    if ( (a3 | 0xF) > 0x7FFFFFFFFFFFFFFFLL || (v10 = v3 >> 1, v3 > 0x7FFFFFFFFFFFFFFFLL - (v3 >> 1)) )
    {
      v12 = 0x8000000000000027uLL;
    }
    else
    {
      v9 = a3 | 0xF;
      if ( (a3 | 0xF) < v10 + v3 )
        v9 = v10 + v3;
      if ( v9 == -1 )
      {
        v11 = 0;
        goto LABEL_20;
      }
      if ( (unsigned __int64)(v9 + 1) < 0x1000 )
      {
        v11 = operator new(v9 + 1);
        goto LABEL_20;
      }
      v12 = v9 + 40;
      if ( v9 + 40 < (unsigned __int64)(v9 + 1) )
        sub_140001180();
    }
    v13 = operator new(v12);
    if ( !v13 )
      goto LABEL_23;
    v11 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v13;
LABEL_20:
    a1[2] = (void *)a3;
    a1[3] = (void *)v9;
    memcpy(v11, a2, a3);
    *((_BYTE *)v11 + a3) = 0;
    if ( v3 > 0xF )
    {
      v14 = (char *)*a1;
      if ( v3 + 1 < 0x1000 )
      {
        v15 = (char *)*a1;
      }
      else
      {
        v15 = (char *)*((_QWORD *)v14 - 1);
        if ( (unsigned __int64)(v14 - v15 - 8) > 0x1F )
LABEL_23:
          __fastfail(5u);
      }
      j_j_free(v15);
    }
    *a1 = v11;
    return a1;
  }
  if ( v3 <= 0xF )
    v7 = a1;
  else
    v7 = *a1;
  a1[2] = (void *)a3;
  memmove(v7, a2, a3);
  *((_BYTE *)v7 + a3) = 0;
  return a1;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (00000001400029EC) ----------------------------------------------------
void *__fastcall sub_1400029EC(__int64 a1, char a2)
{
  return sub_140002580(a1 - *(int *)(a1 - 4), a2);
}

//----- (0000000140002A00) ----------------------------------------------------
void __fastcall sub_140002A00(__int64 a1)
{
  __int64 v1; // rdx
  void *v3; // rcx

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    if ( (unsigned __int64)(8 * ((*(_QWORD *)(a1 + 40) - v1) >> 3)) < 0x1000 )
    {
      v3 = *(void **)(a1 + 24);
    }
    else
    {
      v3 = *(void **)(v1 - 8);
      if ( (unsigned __int64)(v1 - (_QWORD)v3 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v3);
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
  }
  sub_140006350(a1, *(_QWORD ***)(a1 + 8));
  j_j_free(*(void **)(a1 + 8));
}
// 140002A68: variable 'a1' is possibly undefined

//----- (0000000140002A80) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_140002A80(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &LuoInjector::InjectorException::`vftable';
  sub_140001E00(a1 + 24, a2 + 24);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  return a1;
}
// 14000E290: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';
// 140010C10: using guessed type void *LuoInjector::InjectorException::`vftable';

//----- (0000000140002AE0) ----------------------------------------------------
// Hidden C++ exception states: #wind=6
__int64 __fastcall sub_140002AE0(__int64 a1, DWORD a2)
{
  __int64 v4; // rbx
  _QWORD *v5; // rax
  HANDLE v6; // rbx
  bool v7; // al
  _OWORD *v8; // rax
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdx
  DWORD LastError; // ebx
  _BYTE pExceptionObject[64]; // [rsp+30h] [rbp-98h] BYREF
  BOOL Wow64Process[2]; // [rsp+70h] [rbp-58h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [rsp+78h] [rbp-50h] BYREF

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v4 = a1 + 24;
  *(_QWORD *)Wow64Process = a1 + 24;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v5 = operator new(0x38u);
  *v5 = v5;
  v5[1] = v5;
  *(_QWORD *)(v4 + 8) = v5;
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 32) = 0;
  *(_QWORD *)(v4 + 40) = 0;
  *(_QWORD *)(v4 + 48) = 7;
  *(_QWORD *)(v4 + 56) = 8;
  *(_DWORD *)v4 = 1065353216;
  sub_140006510(v4 + 24, 0x10u, *(_QWORD *)(v4 + 8));
  *(_QWORD *)(a1 + 88) = 0;
  *(_WORD *)(a1 + 96) = 0;
  v6 = OpenProcess(0x1FFFFFu, 0, a2);
  *(_QWORD *)a1 = v6;
  if ( !v6 )
  {
    LastError = GetLastError();
    sub_140005A60(&SystemInfo, "Failed to open process");
    sub_140001760((__int64)pExceptionObject, (__int64)&SystemInfo, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  GetSystemInfo(&SystemInfo);
  v7 = SystemInfo.wProcessorArchitecture == 9 && (!IsWow64Process(v6, Wow64Process) || !Wow64Process[0]);
  *(_BYTE *)(a1 + 97) = v7;
  if ( !sub_14000A980(*(void **)a1, (HMODULE *)(a1 + 8)) )
  {
    CloseHandle(*(HANDLE *)a1);
    sub_140005A60(&SystemInfo, "Failed to find mono.dll in target process");
    sub_140001760((__int64)pExceptionObject, (__int64)&SystemInfo, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v8 = operator new(0x48u);
  *(_QWORD *)Wow64Process = v8;
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  v8[3] = 0;
  *((_QWORD *)v8 + 8) = 0;
  v9 = sub_140009030((__int64)v8, *(_QWORD *)a1);
  v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v9;
  if ( v11 )
    sub_140006050(v10, v11);
  return a1;
}
// 140002C29: variable 'v10' is possibly undefined

//----- (0000000140002D20) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
void __fastcall sub_140002D20(__int64 a1)
{
  _QWORD *v1; // rsi
  void *v2; // rcx
  void *v3; // rcx
  void *v4; // rcx
  void *v5; // rcx
  void *v6; // rcx
  void *v7; // rcx
  void *v8; // rcx
  void *v9; // rcx
  void *v10; // rcx
  void *v11; // rcx
  void *v12; // rcx
  void *v13; // rcx
  char **v14; // r14
  size_t *v15; // rdi
  size_t v16; // r8
  size_t v17; // rdx
  __int64 v18; // r9
  size_t i; // rcx
  __int64 v20; // rcx
  size_t v21; // rbx
  _QWORD *v22; // rcx
  _QWORD *j; // rax
  void *v24; // rcx
  void **v25; // rax
  __int64 v26; // rax
  __int128 v27; // [rsp+20h] [rbp-89h] BYREF
  __int64 v28; // [rsp+30h] [rbp-79h]
  unsigned __int64 v29; // [rsp+38h] [rbp-71h]
  _QWORD v30[4]; // [rsp+40h] [rbp-69h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+60h] [rbp-49h] BYREF
  __int128 v32; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v33; // [rsp+B0h] [rbp+7h]

  v1 = (_QWORD *)(a1 + 24);
  v32 = 0;
  v33 = 0;
  sub_14000A1D0((__int64)&v32, *(void **)a1, *(_QWORD *)(a1 + 8));
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_get_root_domain", 0x14u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v2 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v2 = *(void **)(v27 - 8);
    }
    j_j_free(v2);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_thread_attach", 0x12u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v3 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v3 = *(void **)(v27 - 8);
    }
    j_j_free(v3);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_image_open_from_data", 0x19u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v4 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v4 = *(void **)(v27 - 8);
    }
    j_j_free(v4);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_assembly_load_from_full", 0x1Cu);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v5 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v5 = *(void **)(v27 - 8);
    }
    j_j_free(v5);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_assembly_get_image", 0x17u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v6 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v6 = *(void **)(v27 - 8);
    }
    j_j_free(v6);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_class_from_name", 0x14u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v7 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v7 = *(void **)(v27 - 8);
    }
    j_j_free(v7);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_class_get_method_from_name", 0x1Fu);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v8 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v8 = *(void **)(v27 - 8);
    }
    j_j_free(v8);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_runtime_invoke", 0x13u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v9 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v9 = *(void **)(v27 - 8);
    }
    j_j_free(v9);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_assembly_close", 0x13u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v10 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v10 = *(void **)(v27 - 8);
    }
    j_j_free(v10);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_image_strerror", 0x13u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v11 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v11 = *(void **)(v27 - 8);
    }
    j_j_free(v11);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_object_get_class", 0x15u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 > 0xF )
  {
    v12 = (void *)v27;
    if ( v29 + 1 >= 0x1000 )
    {
      if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) > 0x1F )
        goto LABEL_64;
      v12 = *(void **)(v27 - 8);
    }
    j_j_free(v12);
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  sub_140005F50(&v27, "mono_class_get_name", 0x13u);
  *(_QWORD *)(*(_QWORD *)sub_140005CF0(v1, (__int64)v30, (size_t *)&v27) + 48LL) = 0;
  if ( v29 <= 0xF )
    goto LABEL_61;
  v13 = (void *)v27;
  if ( v29 + 1 >= 0x1000 )
  {
    if ( (unsigned __int64)(v27 - *(_QWORD *)(v27 - 8) - 8) <= 0x1F )
    {
      v13 = *(void **)(v27 - 8);
      goto LABEL_60;
    }
LABEL_64:
    __fastfail(5u);
  }
LABEL_60:
  j_j_free(v13);
LABEL_61:
  v14 = (char **)*((_QWORD *)&v32 + 1);
  v15 = (size_t *)v32;
  if ( (_QWORD)v32 != *((_QWORD *)&v32 + 1) )
  {
    do
    {
      v16 = v15[2];
      if ( v15[3] <= 0xF )
        v17 = (size_t)v15;
      else
        v17 = *v15;
      v18 = 0xCBF29CE484222325uLL;
      for ( i = 0; i < v16; ++i )
        v18 = 0x100000001B3LL * (*(unsigned __int8 *)(v17 + i) ^ (unsigned __int64)v18);
      v20 = sub_1400061F0(v1, v30, v15, v18)[1];
      if ( v20 && v20 != v1[1] )
      {
        v21 = v15[4];
        *(_QWORD *)(*(_QWORD *)sub_140005AB0(v1, (__int64)&v27, v15) + 48LL) = v21;
      }
      v15 += 5;
    }
    while ( v15 != (size_t *)v14 );
    v14 = (char **)*((_QWORD *)&v32 + 1);
    v15 = (size_t *)v32;
  }
  v22 = (_QWORD *)v1[1];
  for ( j = (_QWORD *)*v22; j != v22; j = (_QWORD *)*j )
  {
    if ( !j[6] )
    {
      v25 = (void **)sub_1400054C0(&v27, "Failed to obtain address of ", j + 2);
      v26 = sub_1400055A0((__int64)v30, v25, "()");
      sub_140001760((__int64)pExceptionObject, v26, 0);
      throw (LuoInjector::InjectorException *)pExceptionObject;
    }
  }
  if ( v15 )
  {
    sub_1400062C0((char **)v15, v14);
    v24 = (void *)v32;
    if ( (unsigned __int64)(8 * ((v33 - (__int64)v32) >> 3)) >= 0x1000 )
    {
      if ( (unsigned __int64)(v32 - *(_QWORD *)(v32 - 8) - 8) > 0x1F )
        __fastfail(5u);
      v24 = *(void **)(v32 - 8);
    }
    j_j_free(v24);
  }
}

//----- (00000001400034F0) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_1400034F0(__int64 a1)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  void *v4; // r8
  void *v5; // rax
  __int64 v6; // r8
  void *v7; // rcx
  _QWORD *v9; // rax
  void *Block[2]; // [rsp+20h] [rbp-59h] BYREF
  __int64 v11; // [rsp+30h] [rbp-49h]
  unsigned __int64 v12; // [rsp+38h] [rbp-41h]
  __int128 v13; // [rsp+40h] [rbp-39h] BYREF
  __int64 v14; // [rsp+50h] [rbp-29h]
  _BYTE v15[16]; // [rsp+60h] [rbp-19h] BYREF
  _BYTE pExceptionObject[96]; // [rsp+70h] [rbp-9h] BYREF

  v13 = 0;
  v14 = 0;
  *(_OWORD *)Block = 0;
  v11 = 0;
  v12 = 0;
  sub_140005F50(Block, "mono_get_root_domain", 0x14u);
  v2 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v15, (size_t *)Block);
  v3 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v2 + 48LL), &v13);
  if ( v12 > 0xF )
  {
    if ( v12 + 1 < 0x1000 )
    {
      v4 = Block[0];
    }
    else
    {
      v4 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v4 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
  }
  v11 = 0;
  v12 = 15;
  LOBYTE(Block[0]) = 0;
  if ( (_QWORD)v13 )
  {
    if ( (unsigned __int64)(8 * ((v14 - (__int64)v13) >> 3)) < 0x1000 )
    {
      v5 = (void *)v13;
    }
    else
    {
      v5 = *(void **)(v13 - 8);
      if ( (unsigned __int64)(v13 - (_QWORD)v5 - 8) > 0x1F )
        goto LABEL_17;
    }
    j_j_free(v5);
  }
  *(_OWORD *)Block = 0;
  v11 = 0;
  v12 = 0;
  sub_140005F50(Block, "mono_get_root_domain", 0x14u);
  if ( !v3 )
  {
    v9 = sub_140005540(&v13, Block, v6);
    sub_140001760((__int64)pExceptionObject, (__int64)v9, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( v12 > 0xF )
  {
    if ( v12 + 1 < 0x1000 )
    {
      v7 = Block[0];
    }
    else
    {
      v7 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v7 - 8) > 0x1F )
LABEL_17:
        __fastfail(5u);
    }
    j_j_free(v7);
  }
  return v3;
}
// 140003678: variable 'v6' is possibly undefined

//----- (00000001400036A0) ----------------------------------------------------
// Hidden C++ exception states: #wind=8
__int64 __fastcall sub_1400036A0(__int64 a1, _QWORD *a2)
{
  const void *v4; // rsi
  __int64 v5; // rax
  __int64 v6; // rbx
  void *v7; // r8
  void *v8; // rax
  int v9; // eax
  __int64 *v11; // rax
  const void *v12; // rbx
  HANDLE *v13; // rax
  void **v14; // rax
  void **v15; // rax
  __int64 v16; // rax
  __int128 v17; // [rsp+20h] [rbp-A9h] BYREF
  __int64 v18; // [rsp+30h] [rbp-99h]
  unsigned __int64 v19; // [rsp+38h] [rbp-91h]
  __int64 v20; // [rsp+40h] [rbp-89h] BYREF
  void *v21[2]; // [rsp+48h] [rbp-81h] BYREF
  char *v22; // [rsp+58h] [rbp-71h]
  size_t Src[5]; // [rsp+68h] [rbp-61h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+90h] [rbp-39h] BYREF
  _OWORD v25[2]; // [rsp+D0h] [rbp+7h] BYREF

  v4 = sub_140009AC0(*(_QWORD *)(a1 + 16));
  Src[0] = (size_t)sub_1400097D0(*(_QWORD *)(a1 + 16), (__int64)a2);
  Src[1] = a2[1] - *a2;
  Src[2] = 1;
  Src[3] = (size_t)v4;
  v21[0] = operator new(0x20u);
  v22 = (char *)v21[0] + 32;
  memmove(v21[0], Src, 0x20u);
  v21[1] = (char *)v21[0] + 32;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  sub_140005F50(&v17, "mono_image_open_from_data", 0x19u);
  v5 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v25, (size_t *)&v17);
  v6 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v5 + 48LL), v21);
  if ( v19 > 0xF )
  {
    if ( v19 + 1 < 0x1000 )
    {
      v7 = (void *)v17;
    }
    else
    {
      v7 = *(void **)(v17 - 8);
      if ( (unsigned __int64)(v17 - (_QWORD)v7 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v7);
  }
  v18 = 0;
  v19 = 15;
  LOBYTE(v17) = 0;
  if ( v21[0] )
  {
    if ( (unsigned __int64)(8 * ((v22 - (char *)v21[0]) >> 3)) < 0x1000 )
    {
      v8 = v21[0];
    }
    else
    {
      v8 = (void *)*((_QWORD *)v21[0] - 1);
      if ( (unsigned __int64)((char *)v21[0] - (char *)v8 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v8);
  }
  v9 = sub_140009720(*(HANDLE **)(a1 + 16), v4);
  if ( v9 )
  {
    v20 = v9;
    v25[0] = *(_OWORD *)unknown_libname_9(v21, &v20, v21);
    sub_140005790(&v17, (__int64)v25);
    sub_140005A60(Src, "mono_image_strerror");
    v11 = (__int64 *)sub_1400058A0((_QWORD *)(a1 + 24), Src);
    v12 = (const void *)sub_140004970(a1, *v11, &v17);
    sub_140001D90(Src);
    sub_140005720(&v17);
    v13 = (HANDLE *)sub_1400058C0(a1 + 16);
    sub_1400091C0(v13, v25, v12, 0x100u);
    v14 = (void **)sub_140005A60(Src, "mono_image_open_from_data");
    v15 = (void **)sub_1400055A0((__int64)&v17, v14, "() failed: ");
    v16 = sub_140005610((__int64)v21, v15, v25);
    sub_140001760((__int64)pExceptionObject, v16, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  return v6;
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);
// 140005710: using guessed type __int64 __fastcall unknown_libname_9(_QWORD, _QWORD, _QWORD);
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (0000000140003970) ----------------------------------------------------
// Hidden C++ exception states: #wind=9
__int64 __fastcall sub_140003970(__int64 a1, size_t a2)
{
  const void *v4; // rsi
  _BYTE *v5; // rax
  LPVOID v6; // rax
  __int64 v7; // rax
  __int64 v8; // rbx
  void *v9; // r8
  void *v10; // rax
  int v11; // eax
  void *v12; // rcx
  __int64 *v14; // rax
  const void *v15; // rbx
  HANDLE *v16; // rax
  void **v17; // rax
  void **v18; // rax
  __int64 v19; // rax
  __int128 v20; // [rsp+28h] [rbp-D8h] BYREF
  __int64 v21; // [rsp+38h] [rbp-C8h]
  unsigned __int64 v22; // [rsp+40h] [rbp-C0h]
  __int64 v23; // [rsp+48h] [rbp-B8h] BYREF
  void *v24[2]; // [rsp+50h] [rbp-B0h] BYREF
  char *v25; // [rsp+60h] [rbp-A0h]
  size_t Src[4]; // [rsp+70h] [rbp-90h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+90h] [rbp-70h] BYREF
  void *Block[2]; // [rsp+D0h] [rbp-30h] BYREF
  _BYTE *v29; // [rsp+E0h] [rbp-20h]
  _OWORD v30[2]; // [rsp+F0h] [rbp-10h] BYREF

  v4 = sub_140009AC0(*(_QWORD *)(a1 + 16));
  v5 = operator new(1u);
  Block[0] = v5;
  v29 = v5 + 1;
  *v5 = 0;
  Block[1] = v5 + 1;
  v6 = sub_1400097D0(*(_QWORD *)(a1 + 16), (__int64)Block);
  Src[0] = a2;
  Src[1] = (size_t)v6;
  Src[2] = (size_t)v4;
  Src[3] = 0;
  v24[0] = operator new(0x20u);
  v25 = (char *)v24[0] + 32;
  memmove(v24[0], Src, 0x20u);
  v24[1] = (char *)v24[0] + 32;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  sub_140005F50(&v20, "mono_assembly_load_from_full", 0x1Cu);
  v7 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v30, (size_t *)&v20);
  v8 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v7 + 48LL), v24);
  if ( v22 > 0xF )
  {
    if ( v22 + 1 < 0x1000 )
    {
      v9 = (void *)v20;
    }
    else
    {
      v9 = *(void **)(v20 - 8);
      if ( (unsigned __int64)(v20 - (_QWORD)v9 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v9);
  }
  v21 = 0;
  v22 = 15;
  LOBYTE(v20) = 0;
  if ( v24[0] )
  {
    if ( (unsigned __int64)(8 * ((v25 - (char *)v24[0]) >> 3)) < 0x1000 )
    {
      v10 = v24[0];
    }
    else
    {
      v10 = (void *)*((_QWORD *)v24[0] - 1);
      if ( (unsigned __int64)((char *)v24[0] - (char *)v10 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v10);
  }
  v11 = sub_140009720(*(HANDLE **)(a1 + 16), v4);
  if ( v11 )
  {
    v23 = v11;
    v30[0] = *(_OWORD *)unknown_libname_9(v24, &v23, v24);
    sub_140005790(&v20, (__int64)v30);
    sub_140005A60(Src, "mono_image_strerror");
    v14 = (__int64 *)sub_1400058A0((_QWORD *)(a1 + 24), Src);
    v15 = (const void *)sub_140004970(a1, *v14, &v20);
    sub_140001D90(Src);
    sub_140005720(&v20);
    v16 = (HANDLE *)sub_1400058C0(a1 + 16);
    sub_1400091C0(v16, v30, v15, 0x100u);
    v17 = (void **)sub_140005A60(Src, "mono_assembly_load_from_full");
    v18 = (void **)sub_1400055A0((__int64)&v20, v17, "() failed: ");
    v19 = sub_140005610((__int64)v24, v18, v30);
    sub_140001760((__int64)pExceptionObject, v19, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( Block[0] )
  {
    if ( (unsigned __int64)(v29 - (char *)Block[0]) < 0x1000 )
    {
      v12 = Block[0];
    }
    else
    {
      v12 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v12 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v12);
  }
  return v8;
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);
// 140005710: using guessed type __int64 __fastcall unknown_libname_9(_QWORD, _QWORD, _QWORD);
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (0000000140003CB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_140003CB0(__int64 a1, __int64 a2)
{
  _QWORD *v3; // rax
  __int64 v4; // rax
  __int64 v5; // rbx
  void *v6; // r8
  void *v7; // rax
  __int64 v8; // r8
  void *v9; // rcx
  _QWORD *v11; // rax
  void *Block[2]; // [rsp+20h] [rbp-69h] BYREF
  __int64 v13; // [rsp+30h] [rbp-59h]
  unsigned __int64 v14; // [rsp+38h] [rbp-51h]
  _QWORD v15[2]; // [rsp+40h] [rbp-49h] BYREF
  _QWORD *v16; // [rsp+50h] [rbp-39h]
  __int64 v17; // [rsp+60h] [rbp-29h]
  _BYTE v18[24]; // [rsp+68h] [rbp-21h] BYREF
  _BYTE pExceptionObject[96]; // [rsp+80h] [rbp-9h] BYREF

  v17 = a2;
  v3 = operator new(8u);
  v15[0] = v3;
  v16 = v3 + 1;
  *v3 = v17;
  v15[1] = v3 + 1;
  *(_OWORD *)Block = 0;
  v13 = 0;
  v14 = 0;
  sub_140005F50(Block, "mono_assembly_get_image", 0x17u);
  v4 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v18, (size_t *)Block);
  v5 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v4 + 48LL), v15);
  if ( v14 > 0xF )
  {
    if ( v14 + 1 < 0x1000 )
    {
      v6 = Block[0];
    }
    else
    {
      v6 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v6 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v6);
  }
  v13 = 0;
  v14 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v15[0] )
  {
    if ( (unsigned __int64)(8 * (((__int64)v16 - v15[0]) >> 3)) < 0x1000 )
    {
      v7 = (void *)v15[0];
    }
    else
    {
      v7 = *(void **)(v15[0] - 8LL);
      if ( (unsigned __int64)(v15[0] - (_QWORD)v7 - 8LL) > 0x1F )
        goto LABEL_17;
    }
    j_j_free(v7);
  }
  *(_OWORD *)Block = 0;
  v13 = 0;
  v14 = 0;
  sub_140005F50(Block, "mono_assembly_get_image", 0x17u);
  if ( !v5 )
  {
    v11 = sub_140005540(v15, Block, v8);
    sub_140001760((__int64)pExceptionObject, (__int64)v11, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( v14 > 0xF )
  {
    if ( v14 + 1 < 0x1000 )
    {
      v9 = Block[0];
    }
    else
    {
      v9 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v9 - 8) > 0x1F )
LABEL_17:
        __fastfail(5u);
    }
    j_j_free(v9);
  }
  return v5;
}
// 140003E60: variable 'v8' is possibly undefined

//----- (0000000140003E90) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_140003E90(__int64 a1, __int64 a2)
{
  LPVOID v4; // rbx
  LPVOID v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  void *v8; // r8
  void *v9; // rax
  __int64 v10; // r8
  void *v11; // rcx
  _QWORD *v13; // rax
  void *Block[2]; // [rsp+20h] [rbp-79h] BYREF
  __int64 v15; // [rsp+30h] [rbp-69h]
  unsigned __int64 v16; // [rsp+38h] [rbp-61h]
  void *v17[2]; // [rsp+40h] [rbp-59h] BYREF
  char *v18; // [rsp+50h] [rbp-49h]
  _QWORD Src[4]; // [rsp+58h] [rbp-41h] BYREF
  _BYTE v20[24]; // [rsp+78h] [rbp-21h] BYREF
  _BYTE pExceptionObject[96]; // [rsp+90h] [rbp-9h] BYREF

  v4 = sub_140009940(*(_QWORD *)(a1 + 16), (const void **)&qword_140015098);
  v5 = sub_140009940(*(_QWORD *)(a1 + 16), (const void **)aLoader);
  Src[0] = a2;
  Src[1] = v4;
  Src[2] = v5;
  v17[0] = operator new(0x18u);
  v18 = (char *)v17[0] + 24;
  memmove(v17[0], Src, 0x18u);
  v17[1] = (char *)v17[0] + 24;
  *(_OWORD *)Block = 0;
  v15 = 0;
  v16 = 0;
  sub_140005F50(Block, "mono_class_from_name", 0x14u);
  v6 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v20, (size_t *)Block);
  v7 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v6 + 48LL), v17);
  if ( v16 > 0xF )
  {
    if ( v16 + 1 < 0x1000 )
    {
      v8 = Block[0];
    }
    else
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v8 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v8);
  }
  v15 = 0;
  v16 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v17[0] )
  {
    if ( (unsigned __int64)(8 * ((v18 - (char *)v17[0]) >> 3)) < 0x1000 )
    {
      v9 = v17[0];
    }
    else
    {
      v9 = (void *)*((_QWORD *)v17[0] - 1);
      if ( (unsigned __int64)((char *)v17[0] - (char *)v9 - 8) > 0x1F )
        goto LABEL_17;
    }
    j_j_free(v9);
  }
  *(_OWORD *)Block = 0;
  v15 = 0;
  v16 = 0;
  sub_140005F50(Block, "mono_class_from_name", 0x14u);
  if ( !v7 )
  {
    v13 = sub_140005540(Src, Block, v10);
    sub_140001760((__int64)pExceptionObject, (__int64)v13, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( v16 > 0xF )
  {
    if ( v16 + 1 < 0x1000 )
    {
      v11 = Block[0];
    }
    else
    {
      v11 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v11 - 8) > 0x1F )
LABEL_17:
        __fastfail(5u);
    }
    j_j_free(v11);
  }
  return v7;
}
// 14000407D: variable 'v10' is possibly undefined

//----- (00000001400040B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_1400040B0(__int64 a1, __int64 a2)
{
  LPVOID v4; // rax
  __int64 v5; // rax
  __int64 v6; // rbx
  void *v7; // r8
  void *v8; // rax
  __int64 v9; // r8
  void *v10; // rcx
  _QWORD *v12; // rax
  void *Block[2]; // [rsp+20h] [rbp-79h] BYREF
  __int64 v14; // [rsp+30h] [rbp-69h]
  unsigned __int64 v15; // [rsp+38h] [rbp-61h]
  void *v16[2]; // [rsp+40h] [rbp-59h] BYREF
  char *v17; // [rsp+50h] [rbp-49h]
  _QWORD Src[4]; // [rsp+58h] [rbp-41h] BYREF
  _BYTE v19[24]; // [rsp+78h] [rbp-21h] BYREF
  _BYTE pExceptionObject[96]; // [rsp+90h] [rbp-9h] BYREF

  v4 = sub_140009940(*(_QWORD *)(a1 + 16), (const void **)aLoad);
  Src[0] = a2;
  Src[1] = v4;
  Src[2] = 0;
  v16[0] = operator new(0x18u);
  v17 = (char *)v16[0] + 24;
  memmove(v16[0], Src, 0x18u);
  v16[1] = (char *)v16[0] + 24;
  *(_OWORD *)Block = 0;
  v14 = 0;
  v15 = 0;
  sub_140005F50(Block, "mono_class_get_method_from_name", 0x1Fu);
  v5 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v19, (size_t *)Block);
  v6 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v5 + 48LL), v16);
  if ( v15 > 0xF )
  {
    if ( v15 + 1 < 0x1000 )
    {
      v7 = Block[0];
    }
    else
    {
      v7 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v7 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v7);
  }
  v14 = 0;
  v15 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v16[0] )
  {
    if ( (unsigned __int64)(8 * ((v17 - (char *)v16[0]) >> 3)) < 0x1000 )
    {
      v8 = v16[0];
    }
    else
    {
      v8 = (void *)*((_QWORD *)v16[0] - 1);
      if ( (unsigned __int64)((char *)v16[0] - (char *)v8 - 8) > 0x1F )
        goto LABEL_17;
    }
    j_j_free(v8);
  }
  *(_OWORD *)Block = 0;
  v14 = 0;
  v15 = 0;
  sub_140005F50(Block, "mono_class_get_method_from_name", 0x1Fu);
  if ( !v6 )
  {
    v12 = sub_140005540(Src, Block, v9);
    sub_140001760((__int64)pExceptionObject, (__int64)v12, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( v15 > 0xF )
  {
    if ( v15 + 1 < 0x1000 )
    {
      v10 = Block[0];
    }
    else
    {
      v10 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v10 - 8) > 0x1F )
LABEL_17:
        __fastfail(5u);
    }
    j_j_free(v10);
  }
  return v6;
}
// 14000428A: variable 'v9' is possibly undefined

//----- (00000001400042B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=6
_QWORD *__fastcall sub_1400042B0(__int64 a1, _QWORD *a2, __int64 a3)
{
  __int64 *v5; // rax
  __int64 v6; // rax
  __int64 v7; // rbx
  void *v8; // r8
  void *v9; // rax
  __int64 v10; // r8
  void *v11; // rcx
  __int64 *v12; // rax
  __int64 v13; // rax
  const void *v14; // rbx
  void *v15; // r8
  void *v16; // rax
  __int64 v17; // r8
  void *v18; // rcx
  _QWORD *v20; // rax
  _QWORD *v21; // rax
  void *Block[2]; // [rsp+20h] [rbp-89h] BYREF
  __int64 v23; // [rsp+30h] [rbp-79h]
  unsigned __int64 v24; // [rsp+38h] [rbp-71h]
  __int64 v25; // [rsp+40h] [rbp-69h]
  __int128 pExceptionObject; // [rsp+50h] [rbp-59h] BYREF
  _QWORD *v27; // [rsp+60h] [rbp-49h]
  void *v28[2]; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v29; // [rsp+B0h] [rbp+7h]
  unsigned __int64 v30; // [rsp+B8h] [rbp+Fh]

  v25 = a3;
  v5 = (__int64 *)operator new(8u);
  *(_QWORD *)&pExceptionObject = v5;
  v27 = v5 + 1;
  *v5 = v25;
  *((_QWORD *)&pExceptionObject + 1) = v5 + 1;
  *(_OWORD *)Block = 0;
  v23 = 0;
  v24 = 0;
  sub_140005F50(Block, "mono_object_get_class", 0x15u);
  v6 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v28, (size_t *)Block);
  v7 = sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v6 + 48LL), &pExceptionObject);
  if ( v24 > 0xF )
  {
    if ( v24 + 1 < 0x1000 )
    {
      v8 = Block[0];
    }
    else
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v8 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v8);
  }
  v23 = 0;
  v24 = 15;
  LOBYTE(Block[0]) = 0;
  if ( (_QWORD)pExceptionObject )
  {
    if ( (unsigned __int64)(8 * ((__int64)((__int64)v27 - pExceptionObject) >> 3)) < 0x1000 )
    {
      v9 = (void *)pExceptionObject;
    }
    else
    {
      v9 = *(void **)(pExceptionObject - 8);
      if ( (unsigned __int64)(pExceptionObject - (_QWORD)v9 - 8) > 0x1F )
        goto LABEL_36;
    }
    j_j_free(v9);
  }
  *(_OWORD *)Block = 0;
  v23 = 0;
  v24 = 0;
  sub_140005F50(Block, "mono_object_get_class", 0x15u);
  if ( !v7 )
  {
    v21 = sub_140005540(&pExceptionObject, Block, v10);
    sub_140001760((__int64)v28, (__int64)v21, 0);
    throw (LuoInjector::InjectorException *)v28;
  }
  if ( v24 > 0xF )
  {
    if ( v24 + 1 < 0x1000 )
    {
      v11 = Block[0];
    }
    else
    {
      v11 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v11 - 8) > 0x1F )
        goto LABEL_36;
    }
    j_j_free(v11);
  }
  v25 = v7;
  pExceptionObject = 0;
  v27 = 0;
  v12 = (__int64 *)operator new(8u);
  *(_QWORD *)&pExceptionObject = v12;
  v27 = v12 + 1;
  *v12 = v25;
  *((_QWORD *)&pExceptionObject + 1) = v12 + 1;
  *(_OWORD *)Block = 0;
  v23 = 0;
  v24 = 0;
  sub_140005F50(Block, "mono_class_get_name", 0x13u);
  v13 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v28, (size_t *)Block);
  v14 = (const void *)sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v13 + 48LL), &pExceptionObject);
  if ( v24 > 0xF )
  {
    if ( v24 + 1 < 0x1000 )
    {
      v15 = Block[0];
    }
    else
    {
      v15 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v15 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v15);
  }
  v23 = 0;
  v24 = 15;
  LOBYTE(Block[0]) = 0;
  if ( (_QWORD)pExceptionObject )
  {
    if ( (unsigned __int64)(8 * ((__int64)((__int64)v27 - pExceptionObject) >> 3)) < 0x1000 )
    {
      v16 = (void *)pExceptionObject;
    }
    else
    {
      v16 = *(void **)(pExceptionObject - 8);
      if ( (unsigned __int64)(pExceptionObject - (_QWORD)v16 - 8) > 0x1F )
        goto LABEL_36;
    }
    j_j_free(v16);
    pExceptionObject = 0;
    v27 = 0;
  }
  *(_OWORD *)v28 = 0;
  v29 = 0;
  v30 = 0;
  sub_140005F50(v28, "mono_class_get_name", 0x13u);
  if ( !v14 )
  {
    v20 = sub_140005540(Block, v28, v17);
    sub_140001760((__int64)&pExceptionObject, (__int64)v20, 0);
    throw (LuoInjector::InjectorException *)&pExceptionObject;
  }
  if ( v30 > 0xF )
  {
    if ( v30 + 1 < 0x1000 )
    {
      v18 = v28[0];
    }
    else
    {
      v18 = (void *)*((_QWORD *)v28[0] - 1);
      if ( (unsigned __int64)((char *)v28[0] - (char *)v18 - 8) > 0x1F )
LABEL_36:
        __fastfail(5u);
    }
    j_j_free(v18);
  }
  sub_1400091C0(*(HANDLE **)(a1 + 16), a2, v14, 0x100u);
  return a2;
}
// 140004637: variable 'v17' is possibly undefined
// 140004666: variable 'v10' is possibly undefined

//----- (0000000140004690) ----------------------------------------------------
CHAR *__fastcall sub_140004690(__int64 a1, CHAR *a2, __int64 a3)
{
  bool v3; // zf
  HANDLE *v6; // rcx
  __int64 v7; // rdx
  int v9; // eax
  __int64 v10; // r8

  v3 = *(_BYTE *)(a1 + 97) == 0;
  v6 = *(HANDLE **)(a1 + 16);
  v7 = 8;
  if ( !v3 )
    v7 = 16;
  v9 = sub_140009720(v6, (const void *)(a3 + v7));
  v10 = 12;
  if ( *(_BYTE *)(a1 + 97) )
    v10 = 20;
  sub_1400093B0(*(HANDLE **)(a1 + 16), a2, (const void *)(a3 + v10), 2LL * v9);
  return a2;
}

//----- (0000000140004700) ----------------------------------------------------
// Hidden C++ exception states: #wind=7
__int64 __fastcall sub_140004700(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  const void *v5; // rax
  const void *v6; // rsi
  __int64 v7; // rax
  void *v8; // rcx
  void *v9; // rax
  __int64 result; // rax
  __int64 v11; // rbx
  HANDLE *v12; // rax
  __int64 v13; // rdx
  int v14; // eax
  void **v15; // rax
  void **v16; // rax
  __int64 v17; // rax
  void *v18[2]; // [rsp+20h] [rbp-E0h] BYREF
  char *v19; // [rsp+30h] [rbp-D0h]
  _BYTE v20[32]; // [rsp+40h] [rbp-C0h] BYREF
  _BYTE v21[32]; // [rsp+60h] [rbp-A0h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+80h] [rbp-80h] BYREF
  void *Block[2]; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v24; // [rsp+D0h] [rbp-30h]
  unsigned __int64 v25; // [rsp+D8h] [rbp-28h]
  __int64 Src; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v27; // [rsp+E8h] [rbp-18h]
  const void *v28; // [rsp+F8h] [rbp-8h]

  v4 = *(_QWORD *)(a1 + 16);
  if ( *(_BYTE *)(a1 + 97) )
    v5 = sub_140009B80(v4);
  else
    v5 = sub_140009AC0(v4);
  v6 = v5;
  Src = a2;
  v27 = 0;
  v28 = v5;
  v18[0] = operator new(0x20u);
  v19 = (char *)v18[0] + 32;
  memmove(v18[0], &Src, 0x20u);
  v18[1] = (char *)v18[0] + 32;
  *(_OWORD *)Block = 0;
  v24 = 0;
  v25 = 0;
  sub_140005F50(Block, "mono_runtime_invoke", 0x13u);
  v7 = sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v20, (size_t *)Block);
  sub_140004970(a1, *(_QWORD *)(*(_QWORD *)v7 + 48LL), v18);
  if ( v25 > 0xF )
  {
    if ( v25 + 1 < 0x1000 )
    {
      v8 = Block[0];
    }
    else
    {
      v8 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v8 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v8);
  }
  v24 = 0;
  v25 = 15;
  LOBYTE(Block[0]) = 0;
  if ( v18[0] )
  {
    if ( (unsigned __int64)(8 * ((v19 - (char *)v18[0]) >> 3)) < 0x1000 )
    {
      v9 = v18[0];
    }
    else
    {
      v9 = (void *)*((_QWORD *)v18[0] - 1);
      if ( (unsigned __int64)((char *)v18[0] - (char *)v9 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v9);
  }
  result = sub_140009720(*(HANDLE **)(a1 + 16), v6);
  v11 = (int)result;
  if ( (_DWORD)result )
  {
    sub_1400042B0(a1, &Src, (int)result);
    v12 = (HANDLE *)sub_1400058C0(a1 + 16);
    v13 = 16;
    if ( *(_BYTE *)(a1 + 97) )
      v13 = 32;
    v14 = sub_140009720(v12, (const void *)(v11 + v13));
    sub_140004690(a1, (CHAR *)Block, v14);
    v15 = (void **)sub_1400054C0(v18, "Managed method threw exception: (", &Src);
    v16 = (void **)sub_1400055A0((__int64)v20, v15, ") ");
    v17 = sub_140005610((__int64)v21, v16, Block);
    sub_140001760((__int64)pExceptionObject, v17, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  return result;
}

//----- (0000000140004970) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
__int64 __fastcall sub_140004970(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v6; // rcx
  const void *v7; // rax
  const void *v8; // rsi
  void **v9; // r8
  char v10; // bl
  void *v11; // rdx
  void *v12; // rcx
  void *v13; // rax
  char v14; // bl
  void *v15; // rcx
  void *v16; // rcx
  DWORD (__stdcall *v17)(LPVOID); // rax
  HANDLE v18; // rax
  void *v19; // r14
  DWORD v20; // ebx
  HANDLE *v21; // rcx
  __int64 v22; // rbx
  void *v23; // rcx
  DWORD LastError; // ebx
  DWORD v26; // ebx
  DWORD v27; // ebx
  void *v28[4]; // [rsp+40h] [rbp-79h] BYREF
  void *v29[2]; // [rsp+60h] [rbp-59h] BYREF
  unsigned __int64 v30; // [rsp+70h] [rbp-49h]
  void *Block[2]; // [rsp+78h] [rbp-41h] BYREF
  __int64 v32; // [rsp+88h] [rbp-31h]
  _BYTE pExceptionObject[64]; // [rsp+90h] [rbp-29h] BYREF
  SIZE_T NumberOfBytesRead; // [rsp+D0h] [rbp+17h] BYREF
  DWORD ThreadId; // [rsp+D8h] [rbp+1Fh] BYREF
  __int64 Buffer; // [rsp+E0h] [rbp+27h] BYREF

  LODWORD(NumberOfBytesRead) = 0;
  v6 = *(_QWORD *)(a1 + 16);
  if ( *(_BYTE *)(a1 + 97) )
    v7 = sub_140009B80(v6);
  else
    v7 = sub_140009AC0(v6);
  v8 = v7;
  *(_OWORD *)v29 = 0;
  v30 = 0;
  if ( *(_BYTE *)(a1 + 97) )
  {
    v9 = (void **)sub_140005040(a1, v28, a2, (__int64)v7, (__int64)a3);
    v10 = 1;
  }
  else
  {
    v9 = (void **)sub_140004CB0(a1, Block, a2, (int)v7, a3);
    v10 = 2;
  }
  v11 = v9[2];
  v9[2] = 0;
  v12 = v9[1];
  v9[1] = 0;
  v13 = *v9;
  *v9 = 0;
  v29[0] = v13;
  v29[1] = v12;
  v30 = (unsigned __int64)v11;
  v14 = v10 | 4;
  if ( (v14 & 2) != 0 )
  {
    v14 &= ~2u;
    if ( Block[0] )
    {
      if ( v32 - (unsigned __int64)Block[0] < 0x1000 )
      {
        v15 = Block[0];
      }
      else
      {
        v15 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v15 - 8) > 0x1F )
          __fastfail(5u);
      }
      j_j_free(v15);
      *(_OWORD *)Block = 0;
      v32 = 0;
    }
  }
  if ( (v14 & 1) != 0 && v28[0] )
  {
    if ( (void *)((char *)v28[2] - (char *)v28[0]) < (void *)0x1000 )
    {
      v16 = v28[0];
    }
    else
    {
      v16 = (void *)*((_QWORD *)v28[0] - 1);
      if ( (unsigned __int64)((char *)v28[0] - (char *)v16 - 8) > 0x1F )
        goto LABEL_31;
    }
    j_j_free(v16);
  }
  v17 = (DWORD (__stdcall *)(LPVOID))sub_1400097D0(*(_QWORD *)(a1 + 16), (__int64)v29);
  v18 = CreateRemoteThread(*(HANDLE *)a1, 0, 0, v17, 0, 0, &ThreadId);
  v19 = v18;
  if ( !v18 )
  {
    LastError = GetLastError();
    sub_140005A60(v28, "Failed to create remote thread");
    sub_140001760((__int64)pExceptionObject, (__int64)v28, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v20 = WaitForSingleObject(v18, 0xFFFFFFFF);
  CloseHandle(v19);
  if ( v20 )
  {
    v26 = GetLastError();
    sub_140005A60(v28, "Failed to wait for remote thread");
    sub_140001760((__int64)pExceptionObject, (__int64)v28, v26);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v21 = *(HANDLE **)(a1 + 16);
  if ( *(_BYTE *)(a1 + 97) )
  {
    NumberOfBytesRead = 0;
    if ( !ReadProcessMemory(*v21, v8, &Buffer, 8u, &NumberOfBytesRead) )
    {
      v27 = GetLastError();
      sub_140005A60(v28, "Failed to read process memory");
      sub_140001760((__int64)pExceptionObject, (__int64)v28, v27);
      throw (LuoInjector::InjectorException *)pExceptionObject;
    }
    v22 = Buffer;
  }
  else
  {
    v22 = (int)sub_140009720(v21, v8);
  }
  if ( v22 == 3221225477LL )
  {
    sub_140005A60(v28, "Access violation occurred while executing function");
    sub_140001760((__int64)pExceptionObject, (__int64)v28, 0);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  if ( v29[0] )
  {
    if ( v30 - (unsigned __int64)v29[0] < 0x1000 )
    {
      v23 = v29[0];
    }
    else
    {
      v23 = (void *)*((_QWORD *)v29[0] - 1);
      if ( (unsigned __int64)((char *)v29[0] - (char *)v23 - 8) > 0x1F )
LABEL_31:
        __fastfail(5u);
    }
    j_j_free(v23);
  }
  return v22;
}

//----- (0000000140004CB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_140004CB0(__int64 a1, _QWORD *a2, int a3, int a4, _QWORD *a5)
{
  __int64 v9; // rbx
  _BYTE *v10; // rdx
  void *v11; // rcx
  __int64 i; // rbx
  _BYTE *v13; // rdx
  _BYTE *v14; // rdx
  __int64 v15; // rcx
  _BYTE *v16; // rbx
  _BYTE *v17; // rax
  size_t v18; // rbx
  size_t v19; // rcx
  void *v20; // rax
  _QWORD *v21; // rdi
  signed __int64 v22; // rbx
  _BYTE *v23; // rcx
  __int16 v25; // [rsp+20h] [rbp-60h] BYREF
  char v26; // [rsp+22h] [rbp-5Eh]
  void *Block[2]; // [rsp+28h] [rbp-58h] BYREF
  __int64 v28; // [rsp+38h] [rbp-48h]
  unsigned __int64 v29; // [rsp+40h] [rbp-40h]
  void *Src[2]; // [rsp+48h] [rbp-38h] BYREF
  _BYTE *v31; // [rsp+58h] [rbp-28h]
  _QWORD v32[2]; // [rsp+60h] [rbp-20h] BYREF

  v32[0] = a2;
  *(_OWORD *)Src = 0;
  v31 = 0;
  if ( *(_BYTE *)(a1 + 96) )
  {
    sub_140001220(Src, *(_QWORD *)(a1 + 88));
    *(_OWORD *)Block = 0;
    v28 = 0;
    v29 = 0;
    sub_140005F50(Block, "mono_thread_attach", 0x12u);
    v9 = *(_QWORD *)(*(_QWORD *)sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v32, (size_t *)Block) + 48LL);
    LOBYTE(v25) = -72;
    if ( Src[1] == v31 )
    {
      sub_1400015A0(Src, (_BYTE *)Src[1], &v25);
      v10 = Src[1];
    }
    else
    {
      *(_BYTE *)Src[1] = -72;
      v10 = ++Src[1];
    }
    LODWORD(v32[0]) = v9;
    sub_140001370((__int64)Src, v10, v32, 4u);
    if ( v29 > 0xF )
    {
      if ( v29 + 1 < 0x1000 )
      {
        v11 = Block[0];
      }
      else
      {
        v11 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v11 - 8) > 0x1F )
          goto LABEL_28;
      }
      j_j_free(v11);
    }
    v25 = -12033;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], &v25, 2u);
    v25 = -15229;
    v26 = 4;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], &v25, 3u);
  }
  for ( i = (unsigned int)((__int64)(a5[1] - *a5) >> 3) - 1; (int)i >= 0; i = (unsigned int)(i - 1) )
    sub_140001220(Src, *(_QWORD *)(*a5 + 8 * i));
  LOBYTE(v25) = -72;
  if ( Src[1] == v31 )
  {
    sub_1400015A0(Src, (_BYTE *)Src[1], &v25);
    v13 = Src[1];
  }
  else
  {
    *(_BYTE *)Src[1] = -72;
    v13 = ++Src[1];
  }
  LODWORD(v32[0]) = a3;
  sub_140001370((__int64)Src, v13, v32, 4u);
  v25 = -12033;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v25, 2u);
  v25 = -15229;
  v26 = 4 * ((__int64)(unsigned int)(*((_DWORD *)a5 + 2) - *(_DWORD *)a5) >> 3);
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v25, 3u);
  LOBYTE(v25) = -93;
  if ( Src[1] == v31 )
  {
    sub_1400015A0(Src, (_BYTE *)Src[1], &v25);
    v14 = Src[1];
  }
  else
  {
    *(_BYTE *)Src[1] = -93;
    v14 = ++Src[1];
  }
  LODWORD(v32[0]) = a4;
  sub_140001370((__int64)Src, v14, v32, 4u);
  LOBYTE(v25) = -61;
  if ( Src[1] == v31 )
  {
    sub_1400015A0(Src, (_BYTE *)Src[1], &v25);
    v16 = Src[1];
  }
  else
  {
    *(_BYTE *)Src[1] = -61;
    v16 = ++Src[1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v17 = Src[0];
  v18 = v16 - (char *)Src[0];
  if ( v18 )
  {
    if ( v18 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001720(v15);
    if ( v18 < 0x1000 )
    {
      v21 = operator new(v18);
    }
    else
    {
      v19 = v18 + 39;
      if ( v18 + 39 < v18 )
        sub_140001180(v19);
      v20 = operator new(v19);
      if ( !v20 )
LABEL_28:
        __fastfail(5u);
      v21 = (_QWORD *)(((unsigned __int64)v20 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v21 - 1) = v20;
    }
    *a2 = v21;
    a2[1] = v21;
    a2[2] = (char *)v21 + v18;
    v22 = (char *)Src[1] - (char *)Src[0];
    memmove(v21, Src[0], (char *)Src[1] - (char *)Src[0]);
    a2[1] = (char *)v21 + v22;
    v17 = Src[0];
  }
  if ( v17 )
  {
    if ( (unsigned __int64)(v31 - v17) < 0x1000 )
    {
      v23 = v17;
    }
    else
    {
      v23 = (_BYTE *)*((_QWORD *)v17 - 1);
      if ( (unsigned __int64)(v17 - v23 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v23);
  }
  return a2;
}
// 140005037: variable 'v15' is possibly undefined
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (0000000140005040) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_140005040(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v9; // rbx
  void *v10; // rcx
  __int64 v11; // rbx
  unsigned __int64 v12; // rdi
  __int64 *i; // rcx
  __int64 v14; // rbx
  __int64 *v15; // r8
  __int64 v16; // rbx
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 v19; // rcx
  _BYTE *v20; // rbx
  _BYTE *v21; // rax
  size_t v22; // rbx
  size_t v23; // rcx
  void *v24; // rax
  _QWORD *v25; // rdi
  signed __int64 v26; // rbx
  _BYTE *v27; // rcx
  _WORD v29[2]; // [rsp+20h] [rbp-71h] BYREF
  __int16 v30; // [rsp+24h] [rbp-6Dh] BYREF
  __int16 v31; // [rsp+28h] [rbp-69h] BYREF
  void *Block[2]; // [rsp+30h] [rbp-61h] BYREF
  __int64 v33; // [rsp+40h] [rbp-51h]
  unsigned __int64 v34; // [rsp+48h] [rbp-49h]
  __int64 v35; // [rsp+50h] [rbp-41h] BYREF
  void *Src[2]; // [rsp+58h] [rbp-39h] BYREF
  _BYTE *v37; // [rsp+68h] [rbp-29h]
  _QWORD v38[2]; // [rsp+70h] [rbp-21h] BYREF
  __int64 v39; // [rsp+80h] [rbp-11h] BYREF
  __int64 v40; // [rsp+88h] [rbp-9h] BYREF
  __int64 v41; // [rsp+90h] [rbp-1h] BYREF

  v38[0] = a2;
  *(_OWORD *)Src = 0;
  v37 = 0;
  LODWORD(v35) = 686588744;
  sub_140001370((__int64)Src, 0, &v35, 4u);
  if ( *(_BYTE *)(a1 + 96) )
  {
    *(_OWORD *)Block = 0;
    v33 = 0;
    v34 = 0;
    sub_140005F50(Block, "mono_thread_attach", 0x12u);
    v9 = *(_QWORD *)(*(_QWORD *)sub_140005CF0((_QWORD *)(a1 + 24), (__int64)v38, (size_t *)Block) + 48LL);
    v29[0] = -18360;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], v29, 2u);
    v35 = v9;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 8u);
    if ( v34 > 0xF )
    {
      if ( v34 + 1 < 0x1000 )
      {
        v10 = Block[0];
      }
      else
      {
        v10 = (void *)*((_QWORD *)Block[0] - 1);
        if ( (unsigned __int64)((char *)Block[0] - (char *)v10 - 8) > 0x1F )
          goto LABEL_27;
      }
      j_j_free(v10);
    }
    v11 = *(_QWORD *)(a1 + 88);
    v29[0] = -18104;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], v29, 2u);
    v35 = v11;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 8u);
    v29[0] = -12033;
    sub_140001370((__int64)Src, (_BYTE *)Src[1], v29, 2u);
  }
  v29[0] = -18360;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], v29, 2u);
  v35 = a3;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 8u);
  v12 = 0;
  for ( i = *(__int64 **)a5; v12 < (__int64)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 3; i = *(__int64 **)a5 )
  {
    if ( v12 >= 4 )
      break;
    if ( v12 )
    {
      if ( v12 == 1 )
      {
        v17 = i[1];
        v31 = -17848;
        sub_140001370((__int64)Src, (_BYTE *)Src[1], &v31, 2u);
        v41 = v17;
        v15 = &v41;
      }
      else if ( v12 == 2 )
      {
        v16 = i[2];
        v30 = -18359;
        sub_140001370((__int64)Src, (_BYTE *)Src[1], &v30, 2u);
        v40 = v16;
        v15 = &v40;
      }
      else
      {
        v14 = i[3];
        v29[0] = -18103;
        sub_140001370((__int64)Src, (_BYTE *)Src[1], v29, 2u);
        v39 = v14;
        v15 = &v39;
      }
    }
    else
    {
      v18 = *i;
      LOWORD(v35) = -18104;
      sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 2u);
      v38[0] = v18;
      v15 = v38;
    }
    sub_140001370((__int64)Src, (_BYTE *)Src[1], v15, 8u);
    ++v12;
  }
  LOWORD(v35) = -12033;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 2u);
  LODWORD(v35) = 683967304;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 4u);
  LOWORD(v35) = -23736;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], &v35, 2u);
  v38[0] = a4;
  sub_140001370((__int64)Src, (_BYTE *)Src[1], v38, 8u);
  LOBYTE(v29[0]) = -61;
  if ( Src[1] == v37 )
  {
    sub_1400015A0(Src, (_BYTE *)Src[1], v29);
    v20 = Src[1];
  }
  else
  {
    *(_BYTE *)Src[1] = -61;
    v20 = ++Src[1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v21 = Src[0];
  v22 = v20 - (char *)Src[0];
  if ( v22 )
  {
    if ( v22 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001720(v19);
    if ( v22 < 0x1000 )
    {
      v25 = operator new(v22);
    }
    else
    {
      v23 = v22 + 39;
      if ( v22 + 39 < v22 )
        sub_140001180(v23);
      v24 = operator new(v23);
      if ( !v24 )
LABEL_27:
        __fastfail(5u);
      v25 = (_QWORD *)(((unsigned __int64)v24 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v25 - 1) = v24;
    }
    *a2 = v25;
    a2[1] = v25;
    a2[2] = (char *)v25 + v22;
    v26 = (char *)Src[1] - (char *)Src[0];
    memmove(v25, Src[0], (char *)Src[1] - (char *)Src[0]);
    a2[1] = (char *)v25 + v26;
    v21 = Src[0];
  }
  if ( v21 )
  {
    if ( (unsigned __int64)(v37 - v21) < 0x1000 )
    {
      v27 = v21;
    }
    else
    {
      v27 = (_BYTE *)*((_QWORD *)v21 - 1);
      if ( (unsigned __int64)(v21 - v27 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v27);
  }
  return a2;
}
// 140005236: conditional instruction was optimized away because rdi.8==3
// 1400054B4: variable 'v19' is possibly undefined
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (00000001400054C0) ----------------------------------------------------
_QWORD *__fastcall sub_1400054C0(_QWORD *a1, const char *a2, _QWORD *a3)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rdx
  __int64 v8; // r8
  size_t v9; // rcx

  v6 = strlen(a2);
  v9 = a3[2];
  if ( 0x7FFFFFFFFFFFFFFFLL - v9 < v6 )
    sub_140001740();
  if ( a3[3] > 0xFu )
    a3 = (_QWORD *)*a3;
  sub_1400060D0(a1, v7, v8, a2, v6, a3, v9);
  return a1;
}
// 140005515: variable 'v7' is possibly undefined
// 140005515: variable 'v8' is possibly undefined
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140005540) ----------------------------------------------------
_QWORD *__fastcall sub_140005540(_QWORD *a1, _QWORD *a2, __int64 a3)
{
  size_t v4; // rcx

  v4 = a2[2];
  if ( 0x7FFFFFFFFFFFFFFFLL - v4 < 0x10 )
    sub_140001740();
  if ( a2[3] > 0xFu )
    a2 = (_QWORD *)*a2;
  sub_1400060D0(a1, (__int64)a2, a3, a2, v4, "() returned NULL", 0x10u);
  return a1;
}
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (00000001400055A0) ----------------------------------------------------
__int64 __fastcall sub_1400055A0(__int64 a1, void **a2, const char *a3)
{
  size_t v6; // rax
  void **v7; // rax

  v6 = strlen(a3);
  v7 = sub_1400063F0(a2, a3, v6);
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v7;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)v7 + 1);
  *(_BYTE *)v7 = 0;
  v7[2] = 0;
  v7[3] = (void *)15;
  return a1;
}

//----- (0000000140005610) ----------------------------------------------------
__int64 __fastcall sub_140005610(__int64 a1, void **a2, _QWORD *a3)
{
  _QWORD *v3; // rax
  unsigned __int64 v4; // r8
  void **v6; // rax

  v3 = a3;
  v4 = a3[2];
  if ( v3[3] > 0xFu )
    v3 = (_QWORD *)*v3;
  v6 = sub_1400063F0(a2, v3, v4);
  *(_OWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_OWORD *)a1 = *(_OWORD *)v6;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)v6 + 1);
  *(_BYTE *)v6 = 0;
  v6[2] = 0;
  v6[3] = (void *)15;
  return a1;
}

//----- (0000000140005790) ----------------------------------------------------
_QWORD *__fastcall sub_140005790(_QWORD *a1, __int64 a2)
{
  const void *v2; // r14
  _QWORD *v3; // rbx
  signed __int64 v5; // rbp
  unsigned __int64 v6; // rdi
  size_t v7; // rdi
  size_t v8; // rcx
  void *v9; // rax

  v2 = *(const void **)a2;
  v3 = 0;
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  *a1 = 0;
  a1[1] = 0;
  v6 = v5 >> 3;
  a1[2] = 0;
  if ( v5 >> 3 )
  {
    if ( v6 > 0x1FFFFFFFFFFFFFFFLL )
      sub_140001720(a1);
    v7 = 8 * v6;
    if ( v7 )
    {
      if ( v7 < 0x1000 )
      {
        v3 = operator new(v7);
      }
      else
      {
        v8 = v7 + 39;
        if ( v7 + 39 < v7 )
          sub_140001180(v8);
        v9 = operator new(v8);
        if ( !v9 )
          __fastfail(5u);
        v3 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
        *(v3 - 1) = v9;
      }
    }
    *a1 = v3;
    a1[1] = v3;
    a1[2] = &v3[v7 / 8];
    memmove(v3, v2, v5);
    a1[1] = &v3[v7 / 8];
  }
  return a1;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (0000000140005870) ----------------------------------------------------
void __fastcall sub_140005870(void **a1)
{
  sub_140006350((__int64)a1, (_QWORD **)*a1);
  j_j_free(*a1);
}

//----- (00000001400058A0) ----------------------------------------------------
__int64 __fastcall sub_1400058A0(_QWORD *a1, size_t *a2)
{
  _BYTE v3[24]; // [rsp+20h] [rbp-18h] BYREF

  return *(_QWORD *)sub_140005CF0(a1, (__int64)v3, a2) + 48LL;
}

//----- (00000001400058C0) ----------------------------------------------------
__int64 __fastcall sub_1400058C0(__int64 a1)
{
  return *(_QWORD *)a1;
}

//----- (00000001400058D0) ----------------------------------------------------
void __fastcall sub_1400058D0(__int64 *a1)
{
  __int64 v1; // rsi
  __int64 ***v2; // rdi
  __int64 **i; // rbx

  v1 = *a1;
  if ( *a1 )
  {
    v2 = *(__int64 ****)(v1 + 16);
    for ( i = *v2; i != (__int64 **)v2; i = (__int64 **)*i )
      VirtualFreeEx(*(HANDLE *)v1, i[2], 0, 0x8000u);
    sub_1400090C0(v1 + 8);
    j_j_free((void *)v1);
  }
}

//----- (0000000140005950) ----------------------------------------------------
_QWORD *__fastcall sub_140005950(_QWORD *a1, size_t a2)
{
  _QWORD *v2; // rdi
  __int64 v3; // rbp
  size_t v7; // rax
  void *v8; // rax
  size_t v9; // rcx

  v2 = 0;
  *(_OWORD *)a1 = 0;
  v3 = 0x7FFFFFFFFFFFFFFFLL;
  a1[2] = 0;
  a1[3] = 0;
  if ( a2 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001740();
  if ( a2 <= 0xF )
  {
    a1[2] = a2;
    a1[3] = 15;
    memset(a1, 0, a2);
    *((_BYTE *)a1 + a2) = 0;
    return a1;
  }
  if ( (a2 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v7 = 0x8000000000000027uLL;
LABEL_6:
    v8 = operator new(v7);
    if ( !v8 )
      __fastfail(5u);
    v2 = (_QWORD *)(((unsigned __int64)v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v2 - 1) = v8;
    goto LABEL_16;
  }
  v3 = a2 | 0xF;
  if ( (a2 | 0xF) < 0x16 )
    v3 = 22;
  v9 = v3 + 1;
  if ( v3 == -1 )
    goto LABEL_16;
  if ( v9 >= 0x1000 )
  {
    v7 = v3 + 40;
    if ( v3 + 40 < (unsigned __int64)(v3 + 1) )
      sub_140001180(v9);
    goto LABEL_6;
  }
  v2 = operator new(v9);
LABEL_16:
  *a1 = v2;
  a1[2] = a2;
  a1[3] = v3;
  memset(v2, 0, a2);
  *((_BYTE *)v2 + a2) = 0;
  return a1;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140005A60) ----------------------------------------------------
_QWORD *__fastcall sub_140005A60(_QWORD *a1, const char *a2)
{
  size_t v4; // rax

  *(_OWORD *)a1 = 0;
  a1[2] = 0;
  a1[3] = 0;
  v4 = strlen(a2);
  sub_140005F50(a1, a2, v4);
  return a1;
}

//----- (0000000140005AB0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_140005AB0(_QWORD *a1, __int64 a2, size_t *a3)
{
  size_t v6; // r8
  size_t v7; // rdx
  __int64 v8; // rdi
  size_t i; // rcx
  _QWORD *v10; // rsi
  _QWORD *v11; // r14
  __int64 v12; // rcx
  float v13; // xmm0_4
  __int64 v14; // rcx
  float v15; // xmm1_4
  __int64 v16; // rax
  __int64 v17; // r8
  _QWORD *v18; // rbx
  _QWORD *v19; // rdx
  _QWORD *v20; // r12
  size_t v21; // rsi
  _QWORD *v22; // rdx
  const void *v23; // rcx
  _QWORD *v24; // r8
  __int64 v25; // rcx
  __int64 v26; // rax
  _QWORD *v27; // r9
  _QWORD *v29; // [rsp+30h] [rbp-48h] BYREF
  __int64 v30; // [rsp+38h] [rbp-40h]

  v6 = a3[2];
  if ( a3[3] <= 0xF )
    v7 = (size_t)a3;
  else
    v7 = *a3;
  v8 = 0xCBF29CE484222325uLL;
  for ( i = 0; i < v6; ++i )
    v8 = 0x100000001B3LL * (*(unsigned __int8 *)(v7 + i) ^ (unsigned __int64)v8);
  sub_1400061F0(a1, &v29, a3, v8);
  if ( !v30 )
  {
    if ( a1[2] == 0x492492492492492LL )
      std::_Xlength_error("unordered_map/set too long");
    v10 = a1 + 1;
    v11 = operator new(0x38u);
    sub_140001E00((__int64)(v11 + 2), (__int64)a3);
    v11[6] = 0;
    v12 = a1[2] + 1LL;
    if ( v12 < 0 )
      v13 = (float)(v12 & 1 | (unsigned int)((unsigned __int64)v12 >> 1))
          + (float)(v12 & 1 | (unsigned int)((unsigned __int64)v12 >> 1));
    else
      v13 = (float)(int)v12;
    v14 = a1[7];
    if ( v14 < 0 )
    {
      v16 = a1[7] & 1LL | ((unsigned __int64)v14 >> 1);
      v15 = (float)(int)v16 + (float)(int)v16;
    }
    else
    {
      v15 = (float)(int)v14;
    }
    if ( (float)(v13 / v15) <= *(float *)a1 )
    {
      v19 = v29;
    }
    else
    {
      sub_140006650((float *)a1);
      v17 = a1[3];
      v18 = *(_QWORD **)(v17 + 16 * (a1[6] & v8) + 8);
      v19 = (_QWORD *)*v10;
      if ( v18 != (_QWORD *)*v10 )
      {
        v20 = *(_QWORD **)(v17 + 16 * (a1[6] & v8));
        v21 = v11[4];
        while ( 1 )
        {
          v22 = v18 + 2;
          if ( v18[5] > 0xFu )
            v22 = (_QWORD *)*v22;
          if ( v11[5] <= 0xFu )
            v23 = v11 + 2;
          else
            v23 = (const void *)v11[2];
          if ( v21 == v18[4] && (!v21 || !memcmp(v23, v22, v21)) )
          {
            v19 = (_QWORD *)*v18;
            v10 = a1 + 1;
            goto LABEL_32;
          }
          if ( v18 == v20 )
            break;
          v18 = (_QWORD *)v18[1];
        }
        v19 = v18;
        v10 = a1 + 1;
      }
    }
LABEL_32:
    v24 = (_QWORD *)v19[1];
    ++a1[2];
    *v11 = v19;
    v11[1] = v24;
    *v24 = v11;
    v19[1] = v11;
    v25 = a1[3];
    v26 = 2 * (v8 & a1[6]);
    v27 = *(_QWORD **)(v25 + 16 * (v8 & a1[6]));
    if ( v27 == (_QWORD *)*v10 )
    {
      *(_QWORD *)(v25 + 16 * (v8 & a1[6])) = v11;
LABEL_37:
      *(_QWORD *)(v25 + 8 * v26 + 8) = v11;
      goto LABEL_38;
    }
    if ( v27 == v19 )
    {
      *(_QWORD *)(v25 + 16 * (v8 & a1[6])) = v11;
    }
    else if ( *(_QWORD **)(v25 + 16 * (v8 & a1[6]) + 8) == v24 )
    {
      goto LABEL_37;
    }
LABEL_38:
    *(_QWORD *)a2 = v11;
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
  *(_QWORD *)a2 = v30;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140005CF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_140005CF0(_QWORD *a1, __int64 a2, size_t *a3)
{
  size_t v6; // r8
  size_t v7; // rdx
  __int64 v8; // rdi
  size_t i; // rcx
  _QWORD *v10; // rsi
  char *v11; // r15
  __int64 v12; // rcx
  float v13; // xmm0_4
  __int64 v14; // rcx
  float v15; // xmm1_4
  __int64 v16; // rax
  __int64 v17; // r8
  _QWORD *v18; // rbx
  _QWORD *v19; // rdx
  _QWORD *v20; // r13
  size_t v21; // rsi
  _QWORD *v22; // rdx
  const void *v23; // rcx
  _QWORD *v24; // r8
  __int64 v25; // rcx
  __int64 v26; // rax
  _QWORD *v27; // r9
  _QWORD *v29; // [rsp+30h] [rbp-48h] BYREF
  __int64 v30; // [rsp+38h] [rbp-40h]

  v6 = a3[2];
  if ( a3[3] <= 0xF )
    v7 = (size_t)a3;
  else
    v7 = *a3;
  v8 = 0xCBF29CE484222325uLL;
  for ( i = 0; i < v6; ++i )
    v8 = 0x100000001B3LL * (*(unsigned __int8 *)(v7 + i) ^ (unsigned __int64)v8);
  sub_1400061F0(a1, &v29, a3, v8);
  if ( !v30 )
  {
    if ( a1[2] == 0x492492492492492LL )
      std::_Xlength_error("unordered_map/set too long");
    v10 = a1 + 1;
    v11 = (char *)operator new(0x38u);
    *((_OWORD *)v11 + 1) = 0;
    *((_QWORD *)v11 + 4) = 0;
    *((_QWORD *)v11 + 5) = 0;
    *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
    *((_OWORD *)v11 + 2) = *((_OWORD *)a3 + 1);
    a3[2] = 0;
    a3[3] = 15;
    *(_BYTE *)a3 = 0;
    *((_QWORD *)v11 + 6) = 0;
    v12 = a1[2] + 1LL;
    if ( v12 < 0 )
      v13 = (float)(v12 & 1 | (unsigned int)((unsigned __int64)v12 >> 1))
          + (float)(v12 & 1 | (unsigned int)((unsigned __int64)v12 >> 1));
    else
      v13 = (float)(int)v12;
    v14 = a1[7];
    if ( v14 < 0 )
    {
      v16 = a1[7] & 1LL | ((unsigned __int64)v14 >> 1);
      v15 = (float)(int)v16 + (float)(int)v16;
    }
    else
    {
      v15 = (float)(int)v14;
    }
    if ( (float)(v13 / v15) <= *(float *)a1 )
    {
      v19 = v29;
    }
    else
    {
      sub_140006650((float *)a1);
      v17 = a1[3];
      v18 = *(_QWORD **)(v17 + 16 * (a1[6] & v8) + 8);
      v19 = (_QWORD *)*v10;
      if ( v18 != (_QWORD *)*v10 )
      {
        v20 = *(_QWORD **)(v17 + 16 * (a1[6] & v8));
        v21 = *((_QWORD *)v11 + 4);
        while ( 1 )
        {
          v22 = v18 + 2;
          if ( v18[5] > 0xFu )
            v22 = (_QWORD *)*v22;
          if ( *((_QWORD *)v11 + 5) <= 0xFu )
            v23 = v11 + 16;
          else
            v23 = (const void *)*((_QWORD *)v11 + 2);
          if ( v21 == v18[4] && (!v21 || !memcmp(v23, v22, v21)) )
          {
            v19 = (_QWORD *)*v18;
            v10 = a1 + 1;
            goto LABEL_32;
          }
          if ( v18 == v20 )
            break;
          v18 = (_QWORD *)v18[1];
        }
        v19 = v18;
        v10 = a1 + 1;
      }
    }
LABEL_32:
    v24 = (_QWORD *)v19[1];
    ++a1[2];
    *(_QWORD *)v11 = v19;
    *((_QWORD *)v11 + 1) = v24;
    *v24 = v11;
    v19[1] = v11;
    v25 = a1[3];
    v26 = 2 * (v8 & a1[6]);
    v27 = *(_QWORD **)(v25 + 16 * (v8 & a1[6]));
    if ( v27 == (_QWORD *)*v10 )
    {
      *(_QWORD *)(v25 + 16 * (v8 & a1[6])) = v11;
LABEL_37:
      *(_QWORD *)(v25 + 8 * v26 + 8) = v11;
      goto LABEL_38;
    }
    if ( v27 == v19 )
    {
      *(_QWORD *)(v25 + 16 * (v8 & a1[6])) = v11;
    }
    else if ( *(_QWORD **)(v25 + 16 * (v8 & a1[6]) + 8) == v24 )
    {
      goto LABEL_37;
    }
LABEL_38:
    *(_QWORD *)a2 = v11;
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
  *(_QWORD *)a2 = v30;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140005F50) ----------------------------------------------------
void *__fastcall sub_140005F50(_QWORD *a1, const void *a2, size_t a3)
{
  __int64 v3; // rsi
  void *result; // rax
  size_t v8; // rax
  void *v9; // rax
  size_t v10; // rcx
  _QWORD *v11; // rdi

  v3 = 0x7FFFFFFFFFFFFFFFLL;
  if ( a3 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001740();
  if ( a3 <= 0xF )
  {
    a1[2] = a3;
    a1[3] = 15;
    result = memcpy(a1, a2, a3);
    *((_BYTE *)a1 + a3) = 0;
    return result;
  }
  if ( (a3 | 0xF) > 0x7FFFFFFFFFFFFFFFLL )
  {
    v8 = 0x8000000000000027uLL;
LABEL_6:
    v9 = operator new(v8);
    if ( !v9 )
      __fastfail(5u);
    v11 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v11 - 1) = v9;
    goto LABEL_17;
  }
  v3 = a3 | 0xF;
  if ( (a3 | 0xF) < 0x16 )
    v3 = 22;
  v10 = v3 + 1;
  if ( v3 == -1 )
  {
    v11 = 0;
  }
  else
  {
    if ( v10 >= 0x1000 )
    {
      v8 = v3 + 40;
      if ( v3 + 40 < (unsigned __int64)(v3 + 1) )
        sub_140001180();
      goto LABEL_6;
    }
    v11 = operator new(v10);
  }
LABEL_17:
  *a1 = v11;
  a1[2] = a3;
  a1[3] = v3;
  result = memcpy(v11, a2, a3);
  *((_BYTE *)v11 + a3) = 0;
  return result;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140006050) ----------------------------------------------------
void __fastcall sub_140006050(__int64 a1, __int64 a2)
{
  __int64 ***v3; // rdi
  __int64 **i; // rbx

  if ( a2 )
  {
    v3 = *(__int64 ****)(a2 + 16);
    for ( i = *v3; i != (__int64 **)v3; i = (__int64 **)*i )
      VirtualFreeEx(*(HANDLE *)a2, i[2], 0, 0x8000u);
    sub_1400090C0(a2 + 8);
    j_j_free((void *)a2);
  }
}

//----- (00000001400060D0) ----------------------------------------------------
_QWORD *__fastcall sub_1400060D0(_QWORD *a1, __int64 a2, __int64 a3, const void *a4, size_t Size, void *Src, size_t a7)
{
  _QWORD *v7; // rbx
  size_t v10; // r14
  __int64 v11; // rdi
  size_t v12; // rax
  void *v13; // rax
  size_t v14; // rcx

  v7 = 0;
  *(_OWORD *)a1 = 0;
  a1[2] = 0;
  v10 = Size + a7;
  a1[3] = 0;
  if ( Size + a7 <= 0xF )
  {
    v11 = 15;
    v7 = a1;
    goto LABEL_16;
  }
  v11 = 0x7FFFFFFFFFFFFFFFLL;
  if ( (v10 | 0xF) <= 0x7FFFFFFFFFFFFFFFLL )
  {
    v11 = v10 | 0xF;
    if ( (v10 | 0xF) < 0x16 )
      v11 = 22;
    v14 = v11 + 1;
    if ( v11 != -1 )
    {
      if ( v14 >= 0x1000 )
      {
        v12 = v11 + 40;
        if ( v11 + 40 < (unsigned __int64)(v11 + 1) )
          sub_140001180();
        goto LABEL_4;
      }
      v7 = operator new(v14);
    }
    *a1 = v7;
    goto LABEL_16;
  }
  v12 = 0x8000000000000027uLL;
LABEL_4:
  v13 = operator new(v12);
  if ( !v13 )
    __fastfail(5u);
  v7 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v7 - 1) = v13;
  *a1 = v7;
LABEL_16:
  a1[2] = v10;
  a1[3] = v11;
  memcpy(v7, a4, Size);
  memcpy((char *)v7 + Size, Src, a7);
  *((_BYTE *)v7 + v10) = 0;
  return a1;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);

//----- (00000001400061F0) ----------------------------------------------------
_QWORD *__fastcall sub_1400061F0(_QWORD *a1, _QWORD *a2, size_t *a3, __int64 a4)
{
  _QWORD *v4; // rax
  _QWORD *v7; // rdx
  _QWORD *v8; // rbx
  _QWORD *v10; // rbp
  size_t v11; // rsi
  unsigned __int64 v12; // r15
  _QWORD *v13; // rdx
  const void *v14; // rcx

  v4 = (_QWORD *)a1[1];
  v7 = (_QWORD *)(a1[3] + 16 * (a4 & a1[6]));
  v8 = (_QWORD *)v7[1];
  if ( v8 == v4 )
  {
    *a2 = v4;
    a2[1] = 0;
    return a2;
  }
  else
  {
    v10 = (_QWORD *)*v7;
    v11 = a3[2];
    v12 = a3[3];
    while ( 1 )
    {
      v13 = v8 + 2;
      if ( v8[5] > 0xFu )
        v13 = (_QWORD *)*v13;
      if ( v12 <= 0xF )
        v14 = a3;
      else
        v14 = (const void *)*a3;
      if ( v11 == v8[4] && (!v11 || !memcmp(v14, v13, v11)) )
      {
        *a2 = *v8;
        a2[1] = v8;
        return a2;
      }
      if ( v8 == v10 )
        break;
      v8 = (_QWORD *)v8[1];
    }
    *a2 = v8;
    a2[1] = 0;
    return a2;
  }
}

//----- (00000001400062C0) ----------------------------------------------------
void __fastcall sub_1400062C0(char **a1, char **a2)
{
  char **v3; // rbx
  unsigned __int64 v4; // rdx
  char *v5; // rax
  char *v6; // rcx

  if ( a1 != a2 )
  {
    v3 = a1;
    do
    {
      v4 = (unsigned __int64)v3[3];
      if ( v4 > 0xF )
      {
        v5 = *v3;
        if ( v4 + 1 < 0x1000 )
        {
          v6 = *v3;
        }
        else
        {
          v6 = (char *)*((_QWORD *)v5 - 1);
          if ( (unsigned __int64)(v5 - v6 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v6);
      }
      v3[2] = 0;
      v3[3] = (char *)15;
      *(_BYTE *)v3 = 0;
      v3 += 5;
    }
    while ( v3 != a2 );
  }
}

//----- (0000000140006350) ----------------------------------------------------
void __fastcall sub_140006350(__int64 a1, _QWORD **a2)
{
  _QWORD *v2; // rbx
  unsigned __int64 v3; // rdx
  _QWORD *v4; // rdi
  __int64 v5; // rax
  void *v6; // rcx

  *a2[1] = 0;
  v2 = *a2;
  if ( *a2 )
  {
    do
    {
      v3 = v2[5];
      v4 = (_QWORD *)*v2;
      if ( v3 > 0xF )
      {
        v5 = v2[2];
        if ( v3 + 1 < 0x1000 )
        {
          v6 = (void *)v2[2];
        }
        else
        {
          v6 = *(void **)(v5 - 8);
          if ( (unsigned __int64)(v5 - (_QWORD)v6 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v6);
      }
      v2[4] = 0;
      v2[5] = 15;
      *((_BYTE *)v2 + 16) = 0;
      j_j_free(v2);
      v2 = v4;
    }
    while ( v4 );
  }
}

//----- (00000001400063F0) ----------------------------------------------------
void **__fastcall sub_1400063F0(void **Src, const void *a2, unsigned __int64 a3)
{
  char *v5; // rcx
  unsigned __int64 v6; // r8
  _QWORD *v7; // rax
  char *v8; // rbx

  v5 = (char *)Src[2];
  v6 = (unsigned __int64)Src[3];
  if ( a3 > v6 - (unsigned __int64)v5 )
    return sub_140006700(Src, a3, v6, a2, a3);
  Src[2] = &v5[a3];
  if ( v6 <= 0xF )
    v7 = Src;
  else
    v7 = *Src;
  v8 = (char *)v7 + (_QWORD)v5;
  memmove((char *)v7 + (_QWORD)v5, a2, a3);
  v8[a3] = 0;
  return Src;
}

//----- (0000000140006510) ----------------------------------------------------
__int64 __fastcall sub_140006510(__int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r9
  char *v6; // r8
  __int64 v7; // rcx
  __int64 result; // rax
  unsigned __int64 v9; // rsi
  _QWORD *v10; // rdi
  void *v11; // rax
  char *v12; // rax
  __int64 v13; // rcx
  char *v14; // rcx
  unsigned __int64 v15; // rcx

  v3 = *(_QWORD *)(a1 + 8);
  v6 = *(char **)a1;
  v7 = v3 - *(_QWORD *)a1;
  result = v7 >> 3;
  if ( v7 >> 3 >= a2 )
  {
    v15 = (unsigned __int64)(v7 + 7) >> 3;
    if ( (unsigned __int64)v6 > v3 )
      v15 = 0;
    if ( v15 )
    {
      memset64(v6, a3, v15);
      return a3;
    }
    return result;
  }
  if ( a2 > 0x1FFFFFFFFFFFFFFFLL )
    goto LABEL_23;
  v9 = 8 * a2;
  if ( 8 * a2 )
  {
    if ( v9 < 0x1000 )
    {
      v10 = operator new(8 * a2);
      goto LABEL_10;
    }
    if ( v9 + 39 >= v9 )
    {
      v11 = operator new(v9 + 39);
      if ( !v11 )
        goto LABEL_13;
      v10 = (_QWORD *)(((unsigned __int64)v11 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v11;
      goto LABEL_10;
    }
LABEL_23:
    sub_140001180();
  }
  v10 = 0;
LABEL_10:
  v12 = *(char **)a1;
  v13 = (__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3;
  if ( v13 )
  {
    if ( (unsigned __int64)(8 * v13) < 0x1000 )
    {
      v14 = *(char **)a1;
    }
    else
    {
      v14 = (char *)*((_QWORD *)v12 - 1);
      if ( (unsigned __int64)(v12 - v14 - 8) > 0x1F )
LABEL_13:
        __fastfail(5u);
    }
    j_j_free(v14);
  }
  result = (__int64)&v10[v9 / 8];
  *(_QWORD *)a1 = v10;
  *(_QWORD *)(a1 + 8) = &v10[v9 / 8];
  for ( *(_QWORD *)(a1 + 16) = &v10[v9 / 8]; v10 != (_QWORD *)result; ++v10 )
    *v10 = a3;
  return result;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);

//----- (0000000140006650) ----------------------------------------------------
unsigned __int64 __fastcall sub_140006650(float *a1)
{
  __int64 v1; // rdx
  bool v3; // sf
  unsigned __int64 v4; // rdx
  unsigned __int64 v5; // rbx
  float v6; // xmm0_4
  float v7; // xmm0_4
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rax
  unsigned __int64 v10; // rcx

  v1 = *((_QWORD *)a1 + 2);
  v3 = v1 + 1 < 0;
  v4 = v1 + 1;
  v5 = *((_QWORD *)a1 + 7);
  if ( v3 )
    v6 = (float)(int)(v4 & 1 | (v4 >> 1)) + (float)(int)(v4 & 1 | (v4 >> 1));
  else
    v6 = (float)(int)v4;
  v7 = ceilf(v6 / *a1);
  v8 = 0;
  if ( v7 >= 9.223372e18 )
  {
    v7 = v7 - 9.223372e18;
    if ( v7 < 9.223372e18 )
      v8 = 0x8000000000000000uLL;
  }
  v9 = v8 + (unsigned int)(int)v7;
  v10 = 8;
  if ( v9 > 8 )
    v10 = v9;
  if ( v5 < v10 )
  {
    if ( v5 >= 0x200 || (v5 *= 8LL, v5 < v10) )
      v5 = v10;
  }
  return sub_1400068B0(a1, v5);
}

//----- (0000000140006700) ----------------------------------------------------
void **__fastcall sub_140006700(void **Src, unsigned __int64 a2, __int64 a3, const void *a4, size_t Size)
{
  size_t v5; // r12
  __int64 v6; // rbx
  size_t v9; // rbp
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rdx
  _QWORD *v13; // rdi
  size_t v14; // rcx
  void *v15; // rax
  char *v16; // r15
  void *v17; // rbx
  _BYTE *v18; // rcx

  v5 = (size_t)Src[2];
  v6 = 0x7FFFFFFFFFFFFFFFLL;
  if ( 0x7FFFFFFFFFFFFFFFLL - v5 < a2 )
    sub_140001740();
  v9 = v5 + a2;
  v10 = (unsigned __int64)Src[3];
  v11 = (v5 + a2) | 0xF;
  if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v12 = v10 >> 1, v10 > 0x7FFFFFFFFFFFFFFFLL - (v10 >> 1)) )
  {
    v14 = 0x8000000000000027uLL;
  }
  else
  {
    v6 = v11;
    if ( v11 < v10 + v12 )
      v6 = v10 + v12;
    if ( v6 == -1 )
    {
      v13 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int64)(v6 + 1) < 0x1000 )
    {
      v13 = operator new(v6 + 1);
      goto LABEL_15;
    }
    v14 = v6 + 40;
    if ( v6 + 40 < (unsigned __int64)(v6 + 1) )
      sub_140001180();
  }
  v15 = operator new(v14);
  if ( !v15 )
    goto LABEL_19;
  v13 = (_QWORD *)(((unsigned __int64)v15 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v15;
LABEL_15:
  Src[2] = (void *)v9;
  v16 = (char *)v13 + v5;
  Src[3] = (void *)v6;
  if ( v10 <= 0xF )
  {
    memcpy(v13, Src, v5);
    memcpy((char *)v13 + v5, a4, Size);
    v16[Size] = 0;
    goto LABEL_22;
  }
  v17 = *Src;
  memcpy(v13, *Src, v5);
  memcpy((char *)v13 + v5, a4, Size);
  v16[Size] = 0;
  if ( v10 + 1 < 0x1000 )
  {
    j_j_free(v17);
    goto LABEL_22;
  }
  v18 = (_BYTE *)*((_QWORD *)v17 - 1);
  if ( (unsigned __int64)((_BYTE *)v17 - v18 - 8) > 0x1F )
LABEL_19:
    __fastfail(5u);
  j_j_free(v18);
LABEL_22:
  *Src = v13;
  return Src;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (00000001400068B0) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400068B0(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v2; // r13
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rcx
  __int64 v6; // rbx
  _QWORD *v7; // r12
  unsigned __int64 result; // rax
  _QWORD *v9; // rdi
  _QWORD *v10; // rsi
  unsigned __int64 v11; // r9
  _QWORD *v12; // r8
  size_t v13; // r14
  size_t v14; // rdx
  __int64 i; // rcx
  __int64 v16; // rax
  _QWORD *v17; // r13
  _QWORD *v18; // r12
  _QWORD *v19; // rbx
  _QWORD *v20; // rdx
  const void *v21; // rcx
  _QWORD *v22; // r8
  _QWORD *v23; // rdx
  _QWORD *v24; // rcx
  _QWORD *v25; // rax
  _QWORD *v26; // rdx
  const void *v27; // rcx
  _QWORD *v28; // rdx
  _QWORD *v29; // rcx
  _QWORD *v30; // rax
  _QWORD *v31; // r8
  _QWORD *v32; // rdx
  _QWORD *v33; // rcx
  _QWORD *v34; // rax

  v2 = a1;
  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  v4 = v2[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = 1LL << ((unsigned __int8)v5 + 1);
  v7 = v2 + 3;
  sub_140006510((__int64)(v2 + 3), 2 * v6, v4);
  v2[7] = v6;
  result = v6 - 1;
  v2[6] = v6 - 1;
  v9 = *(_QWORD **)v2[1];
  v10 = v9;
  if ( v9 != (_QWORD *)v4 )
  {
    while ( 1 )
    {
      v11 = v9[5];
      v12 = v9 + 2;
      v10 = (_QWORD *)*v10;
      v13 = v9[4];
      if ( v11 > 0xF )
        v12 = (_QWORD *)v9[2];
      v14 = 0;
      for ( i = 0xCBF29CE484222325uLL; v14 < v13; i = 0x100000001B3LL * (v16 ^ i) )
        v16 = *((unsigned __int8 *)v12 + v14++);
      v17 = (_QWORD *)(16 * (v2[6] & i) + *v7);
      v18 = (_QWORD *)*v17;
      if ( *v17 == v4 )
      {
        *v17 = v9;
        v17[1] = v9;
        goto LABEL_33;
      }
      v19 = (_QWORD *)v17[1];
      v20 = v19 + 2;
      if ( v19[5] > 0xFu )
        v20 = (_QWORD *)*v20;
      v21 = v9 + 2;
      if ( v11 > 0xF )
        v21 = (const void *)v9[2];
      if ( v13 != v19[4] )
        goto LABEL_21;
      if ( v13 && memcmp(v21, v20, v9[4]) )
        break;
      v22 = (_QWORD *)*v19;
      if ( (_QWORD *)*v19 != v9 )
      {
        v23 = (_QWORD *)v9[1];
        *v23 = v10;
        v24 = (_QWORD *)v10[1];
        *v24 = v22;
        v25 = (_QWORD *)v22[1];
        *v25 = v9;
        v22[1] = v24;
        v10[1] = v23;
        v9[1] = v25;
      }
      v17[1] = v9;
LABEL_33:
      v2 = a1;
      v9 = v10;
      result = 0xCBF29CE484222325uLL;
      v7 = a1 + 3;
      if ( v10 == (_QWORD *)v4 )
        return result;
    }
    v11 = v9[5];
LABEL_21:
    if ( v18 == v19 )
    {
LABEL_32:
      v28 = (_QWORD *)v9[1];
      *v28 = v10;
      v29 = (_QWORD *)v10[1];
      *v29 = v19;
      v30 = (_QWORD *)v19[1];
      *v30 = v9;
      v19[1] = v29;
      v10[1] = v28;
      v9[1] = v30;
      *v17 = v9;
      goto LABEL_33;
    }
    while ( 1 )
    {
      v19 = (_QWORD *)v19[1];
      v26 = v19 + 2;
      if ( v19[5] > 0xFu )
        v26 = (_QWORD *)*v26;
      if ( v11 <= 0xF )
        v27 = v9 + 2;
      else
        v27 = (const void *)v9[2];
      if ( v13 == v19[4] )
      {
        if ( !v13 || !memcmp(v27, v26, v13) )
        {
          v31 = (_QWORD *)*v19;
          v32 = (_QWORD *)v9[1];
          *v32 = v10;
          v33 = (_QWORD *)v10[1];
          *v33 = v31;
          v34 = (_QWORD *)v31[1];
          *v34 = v9;
          v31[1] = v33;
          v10[1] = v32;
          v9[1] = v34;
          goto LABEL_33;
        }
        v11 = v9[5];
      }
      if ( v18 == v19 )
        goto LABEL_32;
    }
  }
  return result;
}
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140006B40) ----------------------------------------------------
void *sub_140006B40()
{
  return &unk_140015598;
}

//----- (0000000140006B50) ----------------------------------------------------
int sub_140006B50(const char *a1, ...)
{
  FILE *v1; // rbx
  unsigned __int64 *v2; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, a1);
  v1 = _acrt_iob_func(1u);
  v2 = (unsigned __int64 *)sub_140006B40();
  return _stdio_common_vfprintf(*v2, v1, a1, 0, va);
}

//----- (0000000140006BB0) ----------------------------------------------------
_QWORD *__fastcall sub_140006BB0(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad cast";
  *a1 = &std::bad_cast::`vftable';
  return a1;
}
// 140011208: using guessed type void *std::bad_cast::`vftable';

//----- (0000000140006BE0) ----------------------------------------------------
void __noreturn sub_140006BE0()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_140006BB0(pExceptionObject);
  throw (std::bad_cast *)pExceptionObject;
}
// 140006BE0: using guessed type void __noreturn sub_140006BE0();

//----- (0000000140006C00) ----------------------------------------------------
__int64 __fastcall sub_140006C00(__int64 a1, __int64 a2)
{
  *(_QWORD *)a1 = &std::exception::`vftable';
  *(_OWORD *)(a1 + 8) = 0;
  _std_exception_copy(a2 + 8);
  *(_QWORD *)a1 = &std::bad_cast::`vftable';
  return a1;
}
// 14000E290: using guessed type __int64 __fastcall _std_exception_copy(_QWORD);
// 140010AB8: using guessed type void *std::exception::`vftable';
// 140011208: using guessed type void *std::bad_cast::`vftable';

//----- (0000000140006C70) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
_QWORD *__fastcall sub_140006C70(_QWORD *a1)
{
  size_t v2; // rax
  size_t v3; // rbp
  unsigned __int64 v4; // r14
  void **v5; // rbx
  void **v6; // r15
  size_t v7; // rsi
  __int64 v8; // r8
  char *v9; // r8
  void **v10; // r8
  size_t v11; // r8
  void **v12; // rdx
  void *v13; // rcx
  _BYTE v15[256]; // [rsp+30h] [rbp-268h] BYREF
  void *Block[2]; // [rsp+130h] [rbp-168h] BYREF
  size_t v17; // [rsp+140h] [rbp-158h]
  unsigned __int64 v18; // [rsp+148h] [rbp-150h]
  CHAR Filename[272]; // [rsp+150h] [rbp-148h] BYREF

  GetModuleFileNameA(0, Filename, 0x104u);
  *(_OWORD *)Block = 0;
  v17 = 0;
  v18 = 0;
  v2 = strlen(Filename);
  sub_140005F50(Block, Filename, v2);
  v3 = v17;
  v4 = v18;
  v5 = Block;
  v6 = (void **)Block[0];
  if ( v18 > 0xF )
    v5 = (void **)Block[0];
  if ( !v17 )
    goto LABEL_18;
  v7 = v17 - 1;
  if ( v17 - 1 + 3 < 0x10 )
  {
    memset(v15, 0, sizeof(v15));
    v9 = "\\/";
    do
      v15[(unsigned __int8)*v9++] = 1;
    while ( v9 != "" );
    v10 = (void **)((char *)v5 + v7);
    if ( !v15[*((unsigned __int8 *)v5 + v7)] )
    {
      while ( v10 != v5 )
      {
        v10 = (void **)((char *)v10 - 1);
        if ( v15[*(unsigned __int8 *)v10] )
          goto LABEL_11;
      }
      goto LABEL_18;
    }
LABEL_11:
    v8 = (char *)v10 - (char *)v5;
  }
  else
  {
    v8 = sub_14000BA90(v5, v17, "\\/", 2u);
    v4 = v18;
    v3 = v17;
    v6 = (void **)Block[0];
  }
  if ( v8 == -1 )
  {
LABEL_18:
    v11 = 0;
    v12 = (void **)&unk_140010D54;
    goto LABEL_19;
  }
  v11 = v8 + 1;
  if ( v3 < v11 )
    v11 = v3;
  v12 = Block;
  if ( v4 > 0xF )
    v12 = v6;
LABEL_19:
  *(_OWORD *)a1 = 0;
  a1[3] = 0;
  a1[2] = 0;
  sub_140005F50(a1, v12, v11);
  if ( v18 > 0xF )
  {
    if ( v18 + 1 < 0x1000 )
    {
      v13 = Block[0];
    }
    else
    {
      v13 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v13 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v13);
  }
  return a1;
}

//----- (0000000140006EF0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_140006EF0(_QWORD *a1)
{
  HANDLE Toolhelp32Snapshot; // rsi
  int cbMultiByte; // ebx
  CHAR *lpMultiByteStr; // rcx
  const char *v5; // rdx
  const char *v6; // rcx
  _BYTE *v7; // rdx
  LPSTR v8; // rcx
  LPSTR String1[3]; // [rsp+50h] [rbp-288h] BYREF
  unsigned __int64 v11; // [rsp+68h] [rbp-270h]
  PROCESSENTRY32W pe; // [rsp+70h] [rbp-268h] BYREF

  *(_OWORD *)a1 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( Toolhelp32Snapshot != (HANDLE)-1LL )
  {
    memset(&pe.cntUsage, 0, 0x234u);
    pe.dwSize = 568;
    if ( Process32FirstW(Toolhelp32Snapshot, &pe) )
    {
      do
      {
        cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, pe.szExeFile, -1, 0, 0, 0, 0);
        sub_140005950(String1, cbMultiByte - 1);
        lpMultiByteStr = (CHAR *)String1;
        if ( v11 > 0xF )
          lpMultiByteStr = String1[0];
        WideCharToMultiByte(0xFDE9u, 0, pe.szExeFile, -1, lpMultiByteStr, cbMultiByte, 0, 0);
        v5 = (const char *)&Block;
        if ( (unsigned __int64)qword_1400155C0 > 0xF )
          v5 = Block;
        v6 = (const char *)String1;
        if ( v11 > 0xF )
          v6 = String1[0];
        if ( !stricmp(v6, v5) )
        {
          v7 = (_BYTE *)a1[1];
          if ( v7 == (_BYTE *)a1[2] )
          {
            sub_140008D20(a1, v7, &pe.th32ProcessID);
          }
          else
          {
            *(_DWORD *)v7 = pe.th32ProcessID;
            a1[1] += 4LL;
          }
        }
        if ( v11 > 0xF )
        {
          v8 = String1[0];
          if ( v11 + 1 >= 0x1000 )
          {
            if ( (unsigned __int64)&String1[0][-*((_QWORD *)String1[0] - 1) - 8] > 0x1F )
              __fastfail(5u);
            v8 = (LPSTR)*((_QWORD *)String1[0] - 1);
          }
          j_j_free(v8);
        }
      }
      while ( Process32NextW(Toolhelp32Snapshot, &pe) );
    }
    CloseHandle(Toolhelp32Snapshot);
  }
  return a1;
}
// 1400155C0: using guessed type __int64 qword_1400155C0;

//----- (0000000140007100) ----------------------------------------------------
// Hidden C++ exception states: #wind=8
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void **v3; // rax
  const char *v4; // rdi
  void **v5; // rdx
  void **v6; // rax
  void *v7; // rcx
  void **v8; // rdx
  _QWORD *v9; // rax
  signed __int64 v10; // rbx
  __int64 v11; // rax
  const char *v12; // rdx
  void *v13; // rax
  void *v14; // rcx
  void *v15; // rcx
  int v17; // edi
  DWORD *v18; // r15
  DWORD *v19; // rbx
  unsigned __int128 v20; // kr10_16
  DWORD v21; // esi
  size_t v22; // rax
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  void *v27; // rax
  void *v28; // rcx
  void *v29; // rcx
  const char *v30; // rax
  int v31; // [rsp+30h] [rbp-2A8h]
  DWORD v32; // [rsp+34h] [rbp-2A4h]
  DWORD *v33; // [rsp+38h] [rbp-2A0h]
  DWORD *v34; // [rsp+40h] [rbp-298h]
  void *Block[3]; // [rsp+48h] [rbp-290h] BYREF
  unsigned __int64 v36; // [rsp+60h] [rbp-278h]
  const std::exception *v37; // [rsp+68h] [rbp-270h] BYREF
  char v38[32]; // [rsp+70h] [rbp-268h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+90h] [rbp-248h] BYREF
  void *v40[2]; // [rsp+D0h] [rbp-208h] BYREF
  __int128 v41; // [rsp+E0h] [rbp-1F8h]
  unsigned __int128 v42; // [rsp+F0h] [rbp-1E8h] BYREF
  __int64 v43; // [rsp+100h] [rbp-1D8h]
  void *v44[2]; // [rsp+108h] [rbp-1D0h] BYREF
  __int64 v45; // [rsp+118h] [rbp-1C0h]
  HANDLE hObject[2]; // [rsp+120h] [rbp-1B8h] BYREF
  _OWORD v47[4]; // [rsp+130h] [rbp-1A8h] BYREF
  __int128 v48; // [rsp+170h] [rbp-168h]
  __int64 v49; // [rsp+180h] [rbp-158h]
  int v50; // [rsp+18Ch] [rbp-14Ch]
  _QWORD v51[34]; // [rsp+190h] [rbp-148h] BYREF

  SetConsoleOutputCP(0xFDE9u);
  SetConsoleTitleW(L"Yin yi Injector");
  sub_140006B50("\n");
  sub_140006B50(" __     _____ _   _  __   __ ___ \n");
  sub_140006B50(" \\ \\   / /_ _| \\ | | \\ \\ / /|_ _|\n");
  sub_140006B50("  \\ \\ / / | ||  \\| |  \\ V /  | | \n");
  sub_140006B50("   \\ V /  | || |\\  |   | |   | | \n");
  sub_140006B50("    |_|  |___|_| \\_|   |_|  |___|\n");
  sub_140006B50("                                 \n");
  sub_140006B50("\n");
  *(_OWORD *)v44 = 0;
  v45 = 0;
  v3 = (void **)sub_140006C70(Block);
  v4 = (const char *)aYinyiDll;
  v5 = aYinyiDll;
  if ( (unsigned __int64)qword_1400150F0 > 0xF )
    v5 = (void **)aYinyiDll[0];
  v6 = sub_1400063F0(v3, v5, qword_1400150E8);
  *(_OWORD *)v40 = 0;
  v41 = 0u;
  *(_OWORD *)v40 = *(_OWORD *)v6;
  v41 = *((_OWORD *)v6 + 1);
  v6[2] = 0;
  v6[3] = (void *)15;
  *(_BYTE *)v6 = 0;
  if ( v36 > 0xF )
  {
    if ( v36 + 1 < 0x1000 )
    {
      v7 = Block[0];
    }
    else
    {
      v7 = (void *)*((_QWORD *)Block[0] - 1);
      if ( (unsigned __int64)((char *)Block[0] - (char *)v7 - 8) > 0x1F )
        goto LABEL_48;
    }
    j_j_free(v7);
  }
  Block[2] = 0;
  v36 = 15;
  LOBYTE(Block[0]) = 0;
  memset(v51, 0, sizeof(v51));
  v8 = v40;
  if ( *((_QWORD *)&v41 + 1) > 0xFu )
    v8 = (void **)v40[0];
  sub_140008A20((__int64)v51, (const char *)v8);
  *(_QWORD *)((char *)v51 + *(int *)(v51[0] + 4LL)) = &std::ifstream::`vftable';
  *(int *)((char *)&v50 + *(int *)(v51[0] + 4LL)) = *(_DWORD *)(v51[0] + 4LL) - 176;
  if ( !v51[18]
    || (v9 = (_QWORD *)std::istream::tellg(v51, v38), v10 = *v9 + v9[1], v10 <= 0)
    || (std::istream::seekg(v51, 0, 0),
        sub_140008740((char **)v44, v10),
        v11 = std::istream::read(v51, v44[0], v10),
        (unsigned __int8)std::ios_base::operator!(v11 + *(int *)(*(_QWORD *)v11 + 4LL))) )
  {
    *(_QWORD *)((char *)v51 + *(int *)(v51[0] + 4LL)) = &std::ifstream::`vftable';
    *(int *)((char *)&v50 + *(int *)(v51[0] + 4LL)) = *(_DWORD *)(v51[0] + 4LL) - 176;
    sub_140008590((__int64)&v51[2]);
    std::istream::~istream<char,std::char_traits<char>>(&v51[3]);
    std::ios::~ios<char,std::char_traits<char>>(&v51[22]);
    if ( (unsigned __int64)qword_1400150F0 > 0xF )
      v4 = (const char *)aYinyiDll[0];
    sub_140006B50("Failed to load %s\n", v4);
    sub_140006B50("\nPress any key to exit...");
    getch();
    goto LABEL_26;
  }
  *(_QWORD *)((char *)v51 + *(int *)(v51[0] + 4LL)) = &std::ifstream::`vftable';
  *(int *)((char *)&v50 + *(int *)(v51[0] + 4LL)) = *(_DWORD *)(v51[0] + 4LL) - 176;
  sub_140008590((__int64)&v51[2]);
  std::istream::~istream<char,std::char_traits<char>>(&v51[3]);
  std::ios::~ios<char,std::char_traits<char>>(&v51[22]);
  v42 = 0;
  v43 = 0;
  sub_140006EF0(&v42);
  if ( (_QWORD)v42 == *((_QWORD *)&v42 + 1) )
  {
    v12 = (const char *)&::Block;
    if ( (unsigned __int64)qword_1400155C0 > 0xF )
      v12 = ::Block;
    sub_140006B50("Process not found: %s\n", v12);
    sub_140006B50("\nPress any key to exit...");
    getch();
    if ( !(_QWORD)v42 )
      goto LABEL_26;
    if ( (unsigned __int64)(4 * ((v43 - (__int64)v42) >> 2)) < 0x1000 )
    {
      v13 = (void *)v42;
LABEL_25:
      j_j_free(v13);
      v42 = 0;
      v43 = 0;
LABEL_26:
      if ( *((_QWORD *)&v41 + 1) <= 0xFu )
      {
LABEL_32:
        *(_QWORD *)&v41 = 0;
        *((_QWORD *)&v41 + 1) = 15;
        LOBYTE(v40[0]) = 0;
        if ( v44[0] )
        {
          if ( v45 - (unsigned __int64)v44[0] >= 0x1000 )
          {
            v15 = (void *)*((_QWORD *)v44[0] - 1);
            if ( (unsigned __int64)((char *)v44[0] - (char *)v15 - 8) <= 0x1F )
            {
              j_j_free(v15);
              return 1;
            }
LABEL_60:
            __fastfail(5u);
          }
          j_j_free(v44[0]);
        }
        return 1;
      }
      if ( (unsigned __int64)(*((_QWORD *)&v41 + 1) + 1LL) < 0x1000 )
      {
        v14 = v40[0];
LABEL_31:
        j_j_free(v14);
        goto LABEL_32;
      }
      v14 = (void *)*((_QWORD *)v40[0] - 1);
      if ( (unsigned __int64)((char *)v40[0] - (char *)v14 - 8) <= 0x1F )
        goto LABEL_31;
LABEL_54:
      __fastfail(5u);
    }
    v13 = *(void **)(v42 - 8);
    if ( (unsigned __int64)(v42 - (_QWORD)v13 - 8) <= 0x1F )
      goto LABEL_25;
LABEL_48:
    __fastfail(5u);
  }
  sub_140006B50("Found %zu process(es), press any key to inject...", (__int64)(*((_QWORD *)&v42 + 1) - v42) >> 2);
  getch();
  sub_140006B50("\n\n");
  v17 = 0;
  v18 = (DWORD *)*((_QWORD *)&v42 + 1);
  v20 = v42;
  v34 = (DWORD *)(v20 >> 64);
  v19 = (DWORD *)v20;
  while ( 1 )
  {
    v33 = v19;
    if ( v19 == v18 )
      break;
    try
    {
      v21 = *v19;
      v32 = v21;
      *(_OWORD *)hObject = 0;
      memset(v47, 0, sizeof(v47));
      v48 = 0;
      v49 = 0;
      sub_140002AE0((__int64)hObject, v21);
      if ( v44[0] == v44[1] )
      {
        sub_140005A60(Block, "Assembly data cannot be empty");
        sub_140001760((__int64)pExceptionObject, (__int64)Block, 0);
        throw (LuoInjector::InjectorException *)pExceptionObject;
      }
      sub_140002D20((__int64)hObject);
      *((_QWORD *)&v48 + 1) = sub_1400034F0((__int64)hObject);
      v22 = sub_1400036A0((__int64)hObject, v44);
      LOBYTE(v49) = 1;
      v23 = sub_140003970((__int64)hObject, v22);
      v24 = sub_140003CB0((__int64)hObject, v23);
      v25 = sub_140003E90((__int64)hObject, v24);
      v26 = sub_1400040B0((__int64)hObject, v25);
      sub_140004700((__int64)hObject, v26);
      sub_140006B50("[PID %lu] Inject success!\n", v21);
      v31 = ++v17;
      if ( hObject[0] )
        CloseHandle(hObject[0]);
      sub_140002A00((__int64)v47 + 8);
      sub_1400058D0((__int64 *)v47);
      ++v19;
    }
    catch ( const std::exception *v37 )
    {
      v30 = (const char *)(*(__int64 (__fastcall **)(const std::exception *))(*(_QWORD *)v37 + 8LL))(v37);
      sub_140006B50("[PID %lu] Inject failed: %s\n", v32, v30);
      v17 = v31;
      v18 = v34;
      v19 = v33 + 1;
      continue;
    }
  }
  sub_140006B50("\nResult: %d/%zu success\n", v17, (__int64)(*((_QWORD *)&v42 + 1) - v42) >> 2);
  sub_140006B50("\nPress any key to exit...");
  getch();
  if ( (_QWORD)v42 )
  {
    if ( (unsigned __int64)(4 * ((v43 - (__int64)v42) >> 2)) < 0x1000 )
    {
      v27 = (void *)v42;
    }
    else
    {
      v27 = *(void **)(v42 - 8);
      if ( (unsigned __int64)(v42 - (_QWORD)v27 - 8) > 0x1F )
        goto LABEL_48;
    }
    j_j_free(v27);
    v42 = 0;
    v43 = 0;
  }
  if ( *((_QWORD *)&v41 + 1) > 0xFu )
  {
    if ( (unsigned __int64)(*((_QWORD *)&v41 + 1) + 1LL) < 0x1000 )
    {
      v28 = v40[0];
    }
    else
    {
      v28 = (void *)*((_QWORD *)v40[0] - 1);
      if ( (unsigned __int64)((char *)v40[0] - (char *)v28 - 8) > 0x1F )
        goto LABEL_54;
    }
    j_j_free(v28);
  }
  *(_QWORD *)&v41 = 0;
  *((_QWORD *)&v41 + 1) = 15;
  LOBYTE(v40[0]) = 0;
  if ( v44[0] )
  {
    if ( v45 - (unsigned __int64)v44[0] < 0x1000 )
    {
      v29 = v44[0];
    }
    else
    {
      v29 = (void *)*((_QWORD *)v44[0] - 1);
      if ( (unsigned __int64)((char *)v44[0] - (char *)v29 - 8) > 0x1F )
        goto LABEL_60;
    }
    j_j_free(v29);
  }
  return 0;
}
// 14000E108: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14000E1E8: using guessed type __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD);
// 14000E1F0: using guessed type __int64 __fastcall std::istream::read(_QWORD, _QWORD, _QWORD);
// 14000E1F8: using guessed type __int64 __fastcall std::istream::seekg(_QWORD, _QWORD, _QWORD);
// 14000E200: using guessed type __int64 __fastcall std::istream::tellg(_QWORD, _QWORD);
// 14000E208: using guessed type __int64 __fastcall std::ios_base::operator!(_QWORD);
// 140011228: using guessed type void *std::ifstream::`vftable';
// 1400150E8: using guessed type __int64 qword_1400150E8;
// 1400150F0: using guessed type __int64 qword_1400150F0;
// 1400155C0: using guessed type __int64 qword_1400155C0;

//----- (00000001400079B0) ----------------------------------------------------
char __fastcall sub_1400079B0(__int64 a1, __int64 a2)
{
  std::codecvt_base *v3; // rdi
  char result; // al

  v3 = (std::codecvt_base *)sub_1400088D0(a2);
  result = std::codecvt_base::always_noconv(v3);
  if ( result )
  {
    *(_QWORD *)(a1 + 104) = 0;
  }
  else
  {
    *(_QWORD *)(a1 + 104) = v3;
    return std::streambuf::_Init(a1);
  }
  return result;
}
// 14000E1B0: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14000E210: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);

//----- (0000000140007A00) ----------------------------------------------------
__int64 __fastcall sub_140007A00(FILE **a1)
{
  if ( !a1[16] || (*(unsigned int (__fastcall **)(FILE **, __int64))&(*a1)->_flag)(a1, 0xFFFFFFFFLL) == -1 )
    return 0;
  else
    return (unsigned int)(fflush(a1[16]) >= 0) - 1;
}

//----- (0000000140007A50) ----------------------------------------------------
__int64 __fastcall sub_140007A50(__int64 a1, char *a2, size_t a3)
{
  bool v5; // zf
  int v6; // r8d
  FILE *v7; // rcx
  FILE *v8; // rdi
  char **v9; // rcx
  char **v10; // rcx
  int *v11; // rcx
  __int64 v12; // rcx
  char **Base; // [rsp+20h] [rbp-38h] BYREF
  char **Pointer; // [rsp+28h] [rbp-30h] BYREF
  int *Count; // [rsp+30h] [rbp-28h] BYREF

  if ( a2 || (v5 = a3 == 0, v6 = 4, !v5) )
    v6 = 0;
  v7 = *(FILE **)(a1 + 128);
  if ( !v7 || setvbuf(v7, a2, v6, a3) )
    return 0;
  v8 = *(FILE **)(a1 + 128);
  *(_BYTE *)(a1 + 124) = 1;
  *(_BYTE *)(a1 + 113) = 0;
  std::streambuf::_Init(a1);
  if ( v8 )
  {
    Base = 0;
    Pointer = 0;
    Count = 0;
    get_stream_buffer_pointers(v8, &Base, &Pointer, &Count);
    v9 = Base;
    *(_QWORD *)(a1 + 24) = Base;
    *(_QWORD *)(a1 + 32) = v9;
    v10 = Pointer;
    *(_QWORD *)(a1 + 56) = Pointer;
    *(_QWORD *)(a1 + 64) = v10;
    v11 = Count;
    *(_QWORD *)(a1 + 80) = Count;
    *(_QWORD *)(a1 + 88) = v11;
  }
  v12 = qword_1400155C8;
  *(_QWORD *)(a1 + 128) = v8;
  *(_QWORD *)(a1 + 116) = v12;
  *(_QWORD *)(a1 + 104) = 0;
  return a1;
}
// 14000E1B0: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 1400155C8: using guessed type __int64 qword_1400155C8;

//----- (0000000140007B50) ----------------------------------------------------
fpos_t *__fastcall sub_140007B50(__int64 a1, fpos_t *a2, _QWORD *a3)
{
  bool v5; // zf
  _QWORD *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // r8
  fpos_t v10; // rdx
  fpos_t Position; // [rsp+20h] [rbp-28h] BYREF

  v5 = *(_QWORD *)(a1 + 128) == 0;
  Position = *a3 + a3[1];
  if ( v5 || !sub_140008C30(a1) || fsetpos(*(FILE **)(a1 + 128), &Position) )
  {
    *a2 = -1;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    v7 = *(_QWORD **)(a1 + 24);
    *(_QWORD *)(a1 + 116) = a3[2];
    if ( *v7 == a1 + 112 )
    {
      v8 = *(_QWORD *)(a1 + 136);
      v9 = *(_QWORD *)(a1 + 144);
      *v7 = v8;
      **(_QWORD **)(a1 + 56) = v8;
      **(_DWORD **)(a1 + 80) = v9 - v8;
    }
    v10 = *(_QWORD *)(a1 + 116);
    *a2 = Position;
    a2[2] = v10;
    a2[1] = 0;
  }
  return a2;
}

//----- (0000000140007C30) ----------------------------------------------------
fpos_t *__fastcall sub_140007C30(__int64 a1, fpos_t *a2, __int64 a3, int a4)
{
  __int64 v4; // r14
  __int64 v6; // rsi
  _QWORD *v9; // rax
  __int64 v10; // rdx
  __int64 v11; // r8
  fpos_t v12; // rdx
  fpos_t Position; // [rsp+20h] [rbp-38h] BYREF

  v4 = a1 + 112;
  v6 = a3;
  if ( **(_QWORD **)(a1 + 56) == a1 + 112 && a4 == 1 && !*(_QWORD *)(a1 + 104) )
    v6 = a3 - 1;
  if ( !*(_QWORD *)(a1 + 128)
    || !sub_140008C30(a1)
    || (v6 || a4 != 1) && fseeki64(*(FILE **)(a1 + 128), v6, a4)
    || fgetpos(*(FILE **)(a1 + 128), &Position) )
  {
    *a2 = -1;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    v9 = *(_QWORD **)(a1 + 24);
    if ( *v9 == v4 )
    {
      v10 = *(_QWORD *)(a1 + 136);
      v11 = *(_QWORD *)(a1 + 144);
      *v9 = v10;
      **(_QWORD **)(a1 + 56) = v10;
      **(_DWORD **)(a1 + 80) = v11 - v10;
    }
    v12 = *(_QWORD *)(a1 + 116);
    *a2 = Position;
    a2[2] = v12;
    a2[1] = 0;
  }
  return a2;
}

//----- (0000000140007D40) ----------------------------------------------------
__int64 __fastcall sub_140007D40(__int64 a1, char *a2, __int64 a3)
{
  signed __int64 v3; // rbx
  char *v4; // rsi
  void *v8; // r9
  int v9; // ecx
  size_t v10; // r15
  FILE *v11; // r9

  v3 = a3;
  v4 = a2;
  if ( *(_QWORD *)(a1 + 104) )
    return std::streambuf::xsputn();
  v8 = **(void ***)(a1 + 64);
  if ( v8 )
    v9 = **(_DWORD **)(a1 + 88);
  else
    v9 = 0;
  if ( a3 > 0 )
  {
    if ( v9 > 0 )
    {
      v10 = v9;
      if ( a3 < v9 )
        v10 = a3;
      memcpy(v8, a2, v10);
      v3 -= v10;
      **(_DWORD **)(a1 + 88) -= v10;
      **(_QWORD **)(a1 + 64) += (int)v10;
      if ( v3 <= 0 )
        return a3 - v3;
      v4 += v10;
    }
    v11 = *(FILE **)(a1 + 128);
    if ( v11 )
      v3 -= fwrite(v4, 1u, v3, v11);
  }
  return a3 - v3;
}
// 14000E140: using guessed type __int64 std::streambuf::xsputn(void);

//----- (0000000140007E10) ----------------------------------------------------
__int64 __fastcall sub_140007E10(__int64 a1, char *a2, __int64 a3)
{
  size_t v7; // rdi
  const void *v8; // rdx
  int v9; // ecx
  size_t v10; // rbx
  _QWORD *v11; // r8
  __int64 v12; // rcx
  __int64 v13; // rdx
  size_t v14; // rax

  if ( a3 <= 0 )
    return 0;
  if ( *(_QWORD *)(a1 + 104) )
    return std::streambuf::xsgetn();
  v7 = a3;
  v8 = **(const void ***)(a1 + 56);
  if ( v8 )
    v9 = **(_DWORD **)(a1 + 80);
  else
    v9 = 0;
  if ( v9 )
  {
    v10 = a3;
    if ( v9 < (unsigned __int64)a3 )
      v10 = v9;
    memcpy(a2, v8, v10);
    a2 += v10;
    v7 = a3 - v10;
    **(_DWORD **)(a1 + 80) -= v10;
    **(_QWORD **)(a1 + 56) += (int)v10;
  }
  if ( *(_QWORD *)(a1 + 128) )
  {
    v11 = *(_QWORD **)(a1 + 24);
    if ( *v11 == a1 + 112 )
    {
      v12 = *(_QWORD *)(a1 + 136);
      v13 = *(_QWORD *)(a1 + 144);
      *v11 = v12;
      **(_QWORD **)(a1 + 56) = v12;
      **(_DWORD **)(a1 + 80) = v13 - v12;
    }
    if ( v7 <= 0xFFF )
    {
LABEL_18:
      if ( v7 )
        v7 -= fread(a2, 1u, v7, *(FILE **)(a1 + 128));
    }
    else
    {
      while ( 1 )
      {
        v14 = fread(a2, 1u, 0xFFFu, *(FILE **)(a1 + 128));
        v7 -= v14;
        if ( v14 != 4095 )
          break;
        a2 += 4095;
        if ( v7 <= 0xFFF )
          goto LABEL_18;
      }
    }
  }
  return a3 - v7;
}
// 14000E138: using guessed type __int64 std::streambuf::xsgetn(void);

//----- (0000000140007F60) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_140007F60(__int64 a1)
{
  unsigned __int64 v2; // rcx
  int *v3; // rdx
  __int64 v4; // r9
  _QWORD *v5; // rcx
  unsigned __int8 *v6; // rdx
  _QWORD *v8; // r9
  __int64 v9; // rdx
  __int64 v10; // rcx
  int v11; // eax
  unsigned int v12; // ebx
  unsigned int v13; // eax
  __int64 v14; // r8
  unsigned __int64 v15; // rcx
  void **v16; // rax
  void **v17; // rcx
  void **v18; // r8
  int v19; // eax
  int v20; // eax
  void **v21; // rax
  unsigned __int64 v22; // r9
  void **v23; // rcx
  unsigned __int64 v24; // rbx
  unsigned int v25; // eax
  void *v26; // rcx
  void **v27; // rax
  __int64 v28; // rcx
  __int64 v29; // rbx
  __int64 v30; // [rsp+40h] [rbp-9h] BYREF
  unsigned __int8 *v31; // [rsp+48h] [rbp-1h] BYREF
  unsigned __int8 v32; // [rsp+50h] [rbp+7h] BYREF
  _BYTE v33[7]; // [rsp+51h] [rbp+8h] BYREF
  void *Block[2]; // [rsp+58h] [rbp+Fh] BYREF
  unsigned __int64 v35; // [rsp+68h] [rbp+1Fh]
  unsigned __int64 v36; // [rsp+70h] [rbp+27h]

  v2 = **(_QWORD **)(a1 + 56);
  if ( v2 && (v3 = *(int **)(a1 + 80), v4 = *v3, v2 < v2 + v4) )
  {
    *v3 = v4 - 1;
    v5 = *(_QWORD **)(a1 + 56);
    v6 = (unsigned __int8 *)(*v5)++;
    return *v6;
  }
  else if ( *(_QWORD *)(a1 + 128) )
  {
    v8 = *(_QWORD **)(a1 + 24);
    if ( *v8 == a1 + 112 )
    {
      v9 = *(_QWORD *)(a1 + 144);
      v10 = *(_QWORD *)(a1 + 136);
      *v8 = v10;
      **(_QWORD **)(a1 + 56) = v10;
      **(_DWORD **)(a1 + 80) = v9 - v10;
    }
    if ( *(_QWORD *)(a1 + 104) )
    {
      *(_OWORD *)Block = 0;
      v35 = 0;
      v36 = 15;
      LOBYTE(Block[0]) = 0;
      v13 = fgetc(*(FILE **)(a1 + 128));
      v14 = v13;
      if ( v13 == -1 )
      {
LABEL_31:
        v12 = -1;
      }
      else
      {
        while ( 1 )
        {
          v15 = v35;
          if ( v35 >= v36 )
          {
            sub_140008EC0(Block, v36, v14, v14);
          }
          else
          {
            ++v35;
            v16 = Block;
            if ( v36 > 0xF )
              v16 = (void **)Block[0];
            *((_BYTE *)v16 + v15) = v14;
            *((_BYTE *)v16 + v15 + 1) = 0;
          }
          v17 = Block;
          if ( v36 > 0xF )
            v17 = (void **)Block[0];
          v18 = Block;
          if ( v36 > 0xF )
            v18 = (void **)Block[0];
          v19 = std::codecvt<char,char,_Mbstatet>::in(
                  *(_QWORD *)(a1 + 104),
                  a1 + 116,
                  v18,
                  (char *)v17 + v35,
                  &v30,
                  &v32,
                  v33,
                  &v31);
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( v20 )
              break;
          }
          v21 = Block;
          if ( v31 != &v32 )
          {
            if ( v36 > 0xF )
              v21 = (void **)Block[0];
            v28 = v30;
            v29 = (__int64)v21 + v35 - v30;
            if ( v29 > 0 )
            {
              while ( 1 )
              {
                ungetc(*(char *)(--v29 + v28), *(FILE **)(a1 + 128));
                if ( v29 <= 0 )
                  break;
                v28 = v30;
              }
            }
            v12 = v32;
            goto LABEL_32;
          }
          if ( v36 > 0xF )
            v21 = (void **)Block[0];
          v22 = v30 - (_QWORD)v21;
          if ( v35 < v30 - (__int64)v21 )
            v22 = v35;
          v23 = Block;
          if ( v36 > 0xF )
            v23 = (void **)Block[0];
          v24 = v35 - v22;
          memmove(v23, (char *)v23 + v22, v35 - v22 + 1);
          v35 = v24;
          v25 = fgetc(*(FILE **)(a1 + 128));
          v14 = v25;
          if ( v25 == -1 )
            goto LABEL_31;
        }
        if ( v20 != 2 )
          goto LABEL_31;
        v27 = Block;
        if ( v36 > 0xF )
          v27 = (void **)Block[0];
        v12 = *(char *)v27;
      }
LABEL_32:
      if ( v36 > 0xF )
      {
        if ( v36 + 1 < 0x1000 )
        {
          v26 = Block[0];
        }
        else
        {
          v26 = (void *)*((_QWORD *)Block[0] - 1);
          if ( (unsigned __int64)((char *)Block[0] - (char *)v26 - 8) > 0x1F )
            __fastfail(5u);
        }
        j_j_free(v26);
      }
    }
    else
    {
      v11 = fgetc(*(FILE **)(a1 + 128));
      v12 = -1;
      if ( v11 != -1 )
        return (unsigned __int8)v11;
    }
    return v12;
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}
// 14000E1D8: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::in(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140008230) ----------------------------------------------------
__int64 __fastcall sub_140008230(__int64 a1)
{
  unsigned __int8 *v2; // rcx
  __int64 result; // rax
  unsigned int v4; // edi

  v2 = **(unsigned __int8 ***)(a1 + 56);
  if ( v2 && v2 < &v2[**(int **)(a1 + 80)] )
    return *v2;
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a1 + 56LL))(a1);
  v4 = result;
  if ( (_DWORD)result != -1 )
  {
    (*(void (__fastcall **)(__int64, _QWORD))(*(_QWORD *)a1 + 32LL))(a1, (unsigned int)result);
    return v4;
  }
  return result;
}

//----- (00000001400082A0) ----------------------------------------------------
__int64 __fastcall sub_1400082A0(__int64 a1, unsigned int a2)
{
  unsigned int v3; // edi
  unsigned __int64 v4; // rcx
  FILE *v6; // rdx
  _QWORD *v7; // r8
  _BYTE *v8; // rdx
  _QWORD *v9; // r10
  int **v10; // r9

  v3 = a2;
  v4 = **(_QWORD **)(a1 + 56);
  if ( v4 && **(_QWORD **)(a1 + 24) < v4 && (a2 == -1 || *(unsigned __int8 *)(v4 - 1) == a2) )
  {
    ++**(_DWORD **)(a1 + 80);
    --**(_QWORD **)(a1 + 56);
    if ( a2 == -1 )
      return 0;
    return v3;
  }
  v6 = *(FILE **)(a1 + 128);
  if ( !v6 || v3 == -1 )
    return 0xFFFFFFFFLL;
  if ( !*(_QWORD *)(a1 + 104) && ungetc((unsigned __int8)v3, v6) != -1 )
    return v3;
  v7 = *(_QWORD **)(a1 + 56);
  v8 = (_BYTE *)(a1 + 112);
  if ( *v7 == a1 + 112 )
    return 0xFFFFFFFFLL;
  v9 = *(_QWORD **)(a1 + 24);
  v10 = (int **)(a1 + 80);
  *v8 = v3;
  if ( (_BYTE *)*v9 != v8 )
  {
    *(_QWORD *)(a1 + 136) = *v9;
    *(_QWORD *)(a1 + 144) = *v7 + **v10;
  }
  *v9 = v8;
  **(_QWORD **)(a1 + 56) = v8;
  **v10 = 1;
  return v3;
}

//----- (0000000140008390) ----------------------------------------------------
__int64 __fastcall sub_140008390(__int64 a1, unsigned int a2)
{
  unsigned __int64 v5; // rdx
  int *v6; // rax
  __int64 v7; // r8
  _QWORD *v8; // rdx
  _BYTE *v9; // r8
  _QWORD *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  unsigned int v19; // ecx
  __int64 v20; // rsi
  unsigned int v21; // ecx
  _BYTE *v22; // [rsp+40h] [rbp-48h] BYREF
  char *v23; // [rsp+48h] [rbp-40h] BYREF
  char v24; // [rsp+50h] [rbp-38h] BYREF
  _BYTE v25[7]; // [rsp+51h] [rbp-37h] BYREF
  _BYTE Buffer[32]; // [rsp+58h] [rbp-30h] BYREF
  __int64 v27; // [rsp+78h] [rbp-10h] BYREF

  if ( a2 == -1 )
    return 0;
  v5 = **(_QWORD **)(a1 + 64);
  if ( v5 )
  {
    v6 = *(int **)(a1 + 88);
    v7 = *v6;
    if ( v5 < v5 + v7 )
    {
      *v6 = v7 - 1;
      v8 = *(_QWORD **)(a1 + 64);
      v9 = (_BYTE *)(*v8)++;
      *v9 = a2;
      return a2;
    }
  }
  if ( !*(_QWORD *)(a1 + 128) )
    return 0xFFFFFFFFLL;
  v10 = *(_QWORD **)(a1 + 24);
  if ( *v10 == a1 + 112 )
  {
    v11 = *(_QWORD *)(a1 + 136);
    v12 = *(_QWORD *)(a1 + 144);
    *v10 = v11;
    **(_QWORD **)(a1 + 56) = v11;
    **(_DWORD **)(a1 + 80) = v12 - v11;
  }
  v13 = *(_QWORD *)(a1 + 104);
  if ( !v13 )
  {
    v14 = fputc((char)a2, *(FILE **)(a1 + 128));
    v15 = -1;
    if ( v14 != -1 )
      return a2;
    return v15;
  }
  v24 = a2;
  v16 = std::codecvt<char,char,_Mbstatet>::out(v13, a1 + 116, &v24, v25, &v23, Buffer, &v27, &v22);
  if ( v16 )
  {
    v17 = v16 - 1;
    if ( v17 )
    {
      if ( v17 == 2 )
      {
        v18 = fputc(v24, *(FILE **)(a1 + 128));
        v19 = -1;
        if ( v18 != -1 )
          return a2;
        return v19;
      }
      return 0xFFFFFFFFLL;
    }
  }
  if ( v22 != Buffer )
  {
    v20 = v22 - Buffer;
    if ( v20 != fwrite(Buffer, 1u, v22 - Buffer, *(FILE **)(a1 + 128)) )
      return 0xFFFFFFFFLL;
  }
  *(_BYTE *)(a1 + 113) = 1;
  v21 = -1;
  if ( v23 != &v24 )
    return a2;
  return v21;
}
// 14000E1E0: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::out(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140008550) ----------------------------------------------------
void __fastcall sub_140008550(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 128);
  if ( v1 )
    unlock_file(v1);
}

//----- (0000000140008570) ----------------------------------------------------
void __fastcall sub_140008570(__int64 a1)
{
  FILE *v1; // rcx

  v1 = *(FILE **)(a1 + 128);
  if ( v1 )
    lock_file(v1);
}

//----- (0000000140008590) ----------------------------------------------------
__int64 __fastcall sub_140008590(__int64 a1)
{
  _QWORD *v2; // r8
  __int64 v3; // rdx
  __int64 v4; // rcx
  _QWORD *v5; // r8
  __int64 v6; // rdx
  __int64 v7; // rcx

  *(_QWORD *)a1 = &std::filebuf::`vftable';
  if ( *(_QWORD *)(a1 + 128) )
  {
    v2 = *(_QWORD **)(a1 + 24);
    if ( *v2 == a1 + 112 )
    {
      v3 = *(_QWORD *)(a1 + 144);
      v4 = *(_QWORD *)(a1 + 136);
      *v2 = v4;
      **(_QWORD **)(a1 + 56) = v4;
      **(_DWORD **)(a1 + 80) = v3 - v4;
    }
  }
  if ( *(_BYTE *)(a1 + 124) )
  {
    if ( *(_QWORD *)(a1 + 128) )
    {
      v5 = *(_QWORD **)(a1 + 24);
      if ( *v5 == a1 + 112 )
      {
        v6 = *(_QWORD *)(a1 + 144);
        v7 = *(_QWORD *)(a1 + 136);
        *v5 = v7;
        **(_QWORD **)(a1 + 56) = v7;
        **(_DWORD **)(a1 + 80) = v6 - v7;
      }
      sub_140008C30(a1);
      fclose(*(FILE **)(a1 + 128));
    }
    *(_BYTE *)(a1 + 124) = 0;
    *(_BYTE *)(a1 + 113) = 0;
    std::streambuf::_Init(a1);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 116) = qword_1400155C8;
    *(_QWORD *)(a1 + 104) = 0;
  }
  return std::streambuf::~streambuf<char,std::char_traits<char>>(a1);
}
// 14000E110: using guessed type __int64 __fastcall std::streambuf::~streambuf<char,std::char_traits<char>>(_QWORD);
// 14000E1B0: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 140011188: using guessed type void *std::filebuf::`vftable';
// 1400155C8: using guessed type __int64 qword_1400155C8;

//----- (0000000140008670) ----------------------------------------------------
void *__fastcall sub_140008670(__int64 a1, char a2)
{
  void *v2; // rsi
  __int64 v5; // r8

  v2 = (void *)(a1 - 176);
  *(_QWORD *)(*(int *)(*(_QWORD *)(a1 - 176) + 4LL) + a1 - 176) = &std::ifstream::`vftable';
  v5 = *(int *)(*(_QWORD *)(a1 - 176) + 4LL);
  *(_DWORD *)(v5 + a1 - 180) = v5 - 176;
  sub_140008590(a1 - 176 + 16);
  std::istream::~istream<char,std::char_traits<char>>(a1 - 152);
  std::ios::~ios<char,std::char_traits<char>>(a1);
  if ( (a2 & 1) != 0 )
    j_j_free(v2);
  return v2;
}
// 14000E108: using guessed type __int64 __fastcall std::ios::~ios<char,std::char_traits<char>>(_QWORD);
// 14000E1E8: using guessed type __int64 __fastcall std::istream::~istream<char,std::char_traits<char>>(_QWORD);
// 140011228: using guessed type void *std::ifstream::`vftable';

//----- (0000000140008700) ----------------------------------------------------
void *__fastcall sub_140008700(void *Block, char a2)
{
  sub_140008590((__int64)Block);
  if ( (a2 & 1) != 0 )
    j_j_free(Block);
  return Block;
}

//----- (0000000140008740) ----------------------------------------------------
char *__fastcall sub_140008740(char **a1, unsigned __int64 a2)
{
  char *v2; // rbx
  char *result; // rax
  char *v5; // r15
  unsigned __int64 v7; // rcx
  size_t v8; // rbx
  unsigned __int64 v9; // rdx
  size_t v10; // rcx
  void *v11; // rax
  _QWORD *v12; // r14
  char *v13; // rax
  char *v14; // rcx
  unsigned __int64 v15; // rdi

  v2 = a1[1];
  result = *a1;
  v5 = (char *)(v2 - *a1);
  if ( a2 < (unsigned __int64)v5 )
  {
    result += a2;
    a1[1] = result;
    return result;
  }
  if ( a2 <= (unsigned __int64)v5 )
    return result;
  v7 = a1[2] - result;
  if ( a2 <= v7 )
  {
    v15 = a2 - (_QWORD)v5;
    memset(v2, 0, a2 - (_QWORD)v5);
    a1[1] = &v2[v15];
    return &v2[v15];
  }
  v8 = 0x7FFFFFFFFFFFFFFFLL;
  if ( a2 > 0x7FFFFFFFFFFFFFFFLL )
    sub_140001720(v7);
  v9 = v7 >> 1;
  if ( v7 > 0x7FFFFFFFFFFFFFFFLL - (v7 >> 1) )
  {
    v10 = 0x8000000000000026uLL;
LABEL_8:
    v11 = operator new(v10);
    if ( !v11 )
      goto LABEL_21;
    v12 = (_QWORD *)(((unsigned __int64)v11 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
    *(v12 - 1) = v11;
    goto LABEL_18;
  }
  v8 = v7 + v9;
  if ( v7 + v9 < a2 )
    v8 = a2;
  if ( v8 )
  {
    if ( v8 >= 0x1000 )
    {
      v10 = v8 + 39;
      if ( v8 + 39 < v8 )
        sub_140001180(v10);
      goto LABEL_8;
    }
    v12 = operator new(v8);
  }
  else
  {
    v12 = 0;
  }
LABEL_18:
  memset((char *)v12 + (_QWORD)v5, 0, a2 - (_QWORD)v5);
  memmove(v12, *a1, a1[1] - *a1);
  v13 = *a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(a1[2] - v13) < 0x1000 )
    {
      v14 = *a1;
    }
    else
    {
      v14 = (char *)*((_QWORD *)v13 - 1);
      if ( (unsigned __int64)(v13 - v14 - 8) > 0x1F )
LABEL_21:
        __fastfail(5u);
    }
    j_j_free(v14);
  }
  *a1 = (char *)v12;
  a1[1] = (char *)v12 + a2;
  result = (char *)v12 + v8;
  a1[2] = (char *)v12 + v8;
  return result;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (00000001400088D0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_1400088D0(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rdi
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v8; // [rsp+20h] [rbp-48h] BYREF
  _BYTE v9[8]; // [rsp+28h] [rbp-40h] BYREF
  __int64 v10; // [rsp+30h] [rbp-38h] BYREF

  std::_Lockit::_Lockit((std::_Lockit *)v9, 0);
  v8 = qword_1400155A0;
  if ( !std::codecvt<char,char,_Mbstatet>::id )
  {
    std::_Lockit::_Lockit((std::_Lockit *)&v10, 0);
    std::codecvt<char,char,_Mbstatet>::id = ++std::locale::id::_Id_cnt;
    std::_Lockit::~_Lockit((std::_Lockit *)&v10);
  }
  v2 = *(_QWORD *)(a1 + 8);
  v3 = 8LL * std::codecvt<char,char,_Mbstatet>::id;
  if ( std::codecvt<char,char,_Mbstatet>::id >= *(_QWORD *)(v2 + 24) )
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_QWORD *)(v3 + *(_QWORD *)(v2 + 16));
    if ( v4 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(v2 + 36) )
    goto LABEL_10;
  v5 = std::locale::_Getgloballocale();
  if ( std::codecvt<char,char,_Mbstatet>::id < *(_QWORD *)(v5 + 24) )
  {
    v4 = *(_QWORD *)(v3 + *(_QWORD *)(v5 + 16));
LABEL_10:
    if ( v4 )
      goto LABEL_14;
  }
  v4 = v8;
  if ( !v8 )
  {
    if ( std::codecvt<char,char,_Mbstatet>::_Getcat(&v8, a1) == -1 )
      sub_140006BE0();
    v6 = v8;
    v10 = v8;
    sub_14000BABC(v8);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 8LL))(v6);
    v4 = v8;
    qword_1400155A0 = v8;
  }
LABEL_14:
  std::_Lockit::~_Lockit((std::_Lockit *)v9);
  return v4;
}
// 14000892C: write access to const memory at 14000E190 has been detected
// 140008931: write access to const memory at 14000E198 has been detected
// 140006BE0: using guessed type void __noreturn sub_140006BE0(void);
// 14000E178: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);
// 14000E180: using guessed type _QWORD std::_Lockit::_Lockit(std::_Lockit *__hidden this, _DWORD);
// 14000E188: using guessed type __int64 std::locale::_Getgloballocale(void);
// 14000E190: using guessed type int std::locale::id::_Id_cnt;
// 14000E1D0: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::_Getcat(_QWORD, _QWORD);
// 1400155A0: using guessed type __int64 qword_1400155A0;

//----- (0000000140008A20) ----------------------------------------------------
// Hidden C++ exception states: #wind=4
__int64 __fastcall sub_140008A20(__int64 a1, const char *a2)
{
  FILE *v4; // rbx
  __int64 v5; // rax
  std::codecvt_base *v6; // rbx
  void (__fastcall ***v7)(_QWORD, __int64); // rax
  int *Count; // [rsp+50h] [rbp-48h] BYREF
  char **Pointer; // [rsp+58h] [rbp-40h] BYREF
  char **Base; // [rsp+60h] [rbp-38h] BYREF
  __int64 v12; // [rsp+68h] [rbp-30h]

  *(_QWORD *)a1 = &unk_140011218;
  std::ios::ios(a1 + 176);
  std::istream::istream(a1, a1 + 16, 0, 0);
  *(_QWORD *)(*(int *)(*(_QWORD *)a1 + 4LL) + a1) = &std::ifstream::`vftable';
  *(_DWORD *)(*(int *)(*(_QWORD *)a1 + 4LL) + a1 - 4) = *(_DWORD *)(*(_QWORD *)a1 + 4LL) - 176;
  std::streambuf::streambuf(a1 + 16);
  *(_QWORD *)(a1 + 16) = &std::filebuf::`vftable';
  *(_BYTE *)(a1 + 140) = 0;
  *(_BYTE *)(a1 + 129) = 0;
  std::streambuf::_Init(a1 + 16);
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 132) = qword_1400155C8;
  *(_QWORD *)(a1 + 120) = 0;
  v4 = std::_Fiopen(a2, 37, 64);
  if ( v4 )
  {
    *(_BYTE *)(a1 + 140) = 1;
    *(_BYTE *)(a1 + 129) = 0;
    std::streambuf::_Init(a1 + 16);
    Base = 0;
    Pointer = 0;
    Count = 0;
    get_stream_buffer_pointers(v4, &Base, &Pointer, &Count);
    std::streambuf::_Init(a1 + 16);
    *(_QWORD *)(a1 + 144) = v4;
    *(_QWORD *)(a1 + 132) = qword_1400155C8;
    *(_QWORD *)(a1 + 120) = 0;
    v5 = std::streambuf::getloc(a1 + 16, &Base);
    v6 = (std::codecvt_base *)sub_1400088D0(v5);
    if ( std::codecvt_base::always_noconv(v6) )
    {
      *(_QWORD *)(a1 + 120) = 0;
    }
    else
    {
      *(_QWORD *)(a1 + 120) = v6;
      std::streambuf::_Init(a1 + 16);
    }
    if ( v12 )
    {
      v7 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v12 + 16LL))(v12);
      if ( v7 )
        (**v7)(v7, 1);
    }
  }
  else
  {
    std::ios::setstate(a1 + *(int *)(*(_QWORD *)a1 + 4LL), 2, 0);
  }
  return a1;
}
// 14000E0E0: using guessed type __int64 __fastcall std::ios::setstate(_QWORD, _QWORD, _QWORD);
// 14000E0E8: using guessed type __int64 __fastcall std::ios::ios(_QWORD);
// 14000E1A0: using guessed type struct _iobuf *std::_Fiopen(const char *, _DWORD, _DWORD);
// 14000E1A8: using guessed type __int64 __fastcall std::streambuf::getloc(_QWORD, _QWORD);
// 14000E1B0: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14000E1B8: using guessed type __int64 __fastcall std::streambuf::_Init(_QWORD);
// 14000E1C0: using guessed type __int64 __fastcall std::istream::istream(_QWORD, _QWORD, _QWORD, _QWORD);
// 14000E210: using guessed type bool std::codecvt_base::always_noconv(std::codecvt_base *__hidden this);
// 14000E220: using guessed type __int64 __fastcall std::streambuf::streambuf(_QWORD);
// 140011188: using guessed type void *std::filebuf::`vftable';
// 140011228: using guessed type void *std::ifstream::`vftable';
// 1400155C8: using guessed type __int64 qword_1400155C8;

//----- (0000000140008C30) ----------------------------------------------------
bool __fastcall sub_140008C30(__int64 a1)
{
  int v2; // eax
  int v3; // eax
  __int64 v5; // rdi
  _BYTE *v6; // [rsp+30h] [rbp-38h] BYREF
  _BYTE Buffer[32]; // [rsp+38h] [rbp-30h] BYREF
  __int64 v8; // [rsp+58h] [rbp-10h] BYREF

  if ( !*(_QWORD *)(a1 + 104) || !*(_BYTE *)(a1 + 113) )
    return 1;
  if ( (*(unsigned int (__fastcall **)(__int64, __int64))(*(_QWORD *)a1 + 24LL))(a1, 0xFFFFFFFFLL) == -1 )
    return 0;
  v2 = std::codecvt<char,char,_Mbstatet>::unshift(*(_QWORD *)(a1 + 104), a1 + 116, Buffer, &v8, &v6);
  if ( !v2 )
  {
    *(_BYTE *)(a1 + 113) = 0;
    goto LABEL_10;
  }
  v3 = v2 - 1;
  if ( !v3 )
  {
LABEL_10:
    if ( v6 == Buffer )
      return *(_BYTE *)(a1 + 113) == 0;
    v5 = v6 - Buffer;
    if ( v5 == fwrite(Buffer, 1u, v6 - Buffer, *(FILE **)(a1 + 128)) )
      return *(_BYTE *)(a1 + 113) == 0;
    return 0;
  }
  if ( v3 != 2 )
    return 0;
  *(_BYTE *)(a1 + 113) = 0;
  return 1;
}
// 14000E1C8: using guessed type __int64 __fastcall std::codecvt<char,char,_Mbstatet>::unshift(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140008D20) ----------------------------------------------------
_DWORD *__fastcall sub_140008D20(_QWORD *a1, _BYTE *a2, _DWORD *a3)
{
  _BYTE *v3; // r14
  __int64 v6; // rdx
  size_t v8; // rcx
  size_t v9; // r8
  __int64 v10; // r15
  unsigned __int64 v11; // rsi
  size_t v12; // rsi
  _QWORD *v13; // rbx
  void *v14; // rax
  _DWORD *v15; // r14
  void *v16; // rcx
  _BYTE *v17; // r8
  _BYTE *v18; // rdx
  size_t v19; // r8
  _BYTE *v20; // rcx
  _BYTE *v21; // rax

  v3 = (_BYTE *)*a1;
  v6 = (__int64)(a1[1] - *a1) >> 2;
  if ( v6 == 0x3FFFFFFFFFFFFFFFLL )
    sub_140001720(a1);
  v8 = (__int64)(a1[2] - (_QWORD)v3) >> 2;
  v9 = v8 >> 1;
  if ( v8 > 0x3FFFFFFFFFFFFFFFLL - (v8 >> 1) )
    goto LABEL_24;
  v10 = v6 + 1;
  v11 = v6 + 1;
  if ( v8 + v9 >= v6 + 1 )
    v11 = v8 + v9;
  if ( v11 > 0x3FFFFFFFFFFFFFFFLL )
    goto LABEL_24;
  v12 = 4 * v11;
  if ( !v12 )
  {
    v13 = 0;
    goto LABEL_13;
  }
  if ( v12 < 0x1000 )
  {
    v13 = operator new(v12);
    goto LABEL_13;
  }
  v8 = v12 + 39;
  if ( v12 + 39 < v12 )
LABEL_24:
    sub_140001180(v8);
  v14 = operator new(v8);
  if ( !v14 )
    goto LABEL_19;
  v13 = (_QWORD *)(((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v14;
LABEL_13:
  v15 = (_DWORD *)v13 + ((a2 - v3) >> 2);
  *v15 = *a3;
  v16 = v13;
  v17 = (_BYTE *)a1[1];
  v18 = (_BYTE *)*a1;
  if ( a2 == v17 )
  {
    v19 = v17 - v18;
  }
  else
  {
    memmove(v13, v18, a2 - v18);
    v16 = v15 + 1;
    v19 = a1[1] - (_QWORD)a2;
    v18 = a2;
  }
  memmove(v16, v18, v19);
  v20 = (_BYTE *)*a1;
  if ( *a1 )
  {
    if ( (unsigned __int64)(4 * ((__int64)(a1[2] - (_QWORD)v20) >> 2)) < 0x1000 )
    {
      v21 = (_BYTE *)*a1;
    }
    else
    {
      v21 = (_BYTE *)*((_QWORD *)v20 - 1);
      if ( (unsigned __int64)(v20 - v21 - 8) > 0x1F )
LABEL_19:
        __fastfail(5u);
    }
    j_j_free(v21);
  }
  *a1 = v13;
  a1[1] = (char *)v13 + 4 * v10;
  a1[2] = (char *)v13 + v12;
  return v15;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (0000000140008EC0) ----------------------------------------------------
void **__fastcall sub_140008EC0(void **Src, __int64 a2, __int64 a3, char a4)
{
  size_t v4; // r14
  __int64 v5; // rbx
  unsigned __int64 v8; // r15
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rdx
  _QWORD *v11; // rdi
  size_t v12; // rcx
  void *v13; // rax
  void *v14; // rbx
  _BYTE *v15; // rcx

  v4 = (size_t)Src[2];
  v5 = 0x7FFFFFFFFFFFFFFFLL;
  if ( v4 == 0x7FFFFFFFFFFFFFFFLL )
    sub_140001740();
  v8 = (unsigned __int64)Src[3];
  v9 = (v4 + 1) | 0xF;
  if ( v9 > 0x7FFFFFFFFFFFFFFFLL || (v10 = v8 >> 1, v8 > 0x7FFFFFFFFFFFFFFFLL - (v8 >> 1)) )
  {
    v12 = 0x8000000000000027uLL;
  }
  else
  {
    v5 = (v4 + 1) | 0xF;
    if ( v9 < v8 + v10 )
      v5 = v8 + v10;
    if ( v5 == -1 )
    {
      v11 = 0;
      goto LABEL_15;
    }
    if ( (unsigned __int64)(v5 + 1) < 0x1000 )
    {
      v11 = operator new(v5 + 1);
      goto LABEL_15;
    }
    v12 = v5 + 40;
    if ( v5 + 40 < (unsigned __int64)(v5 + 1) )
      sub_140001180(v12);
  }
  v13 = operator new(v12);
  if ( !v13 )
    goto LABEL_19;
  v11 = (_QWORD *)(((unsigned __int64)v13 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v11 - 1) = v13;
LABEL_15:
  Src[2] = (void *)(v4 + 1);
  Src[3] = (void *)v5;
  if ( v8 <= 0xF )
  {
    memcpy(v11, Src, v4);
    *((_BYTE *)v11 + v4) = a4;
    *((_BYTE *)v11 + v4 + 1) = 0;
    goto LABEL_22;
  }
  v14 = *Src;
  memcpy(v11, *Src, v4);
  *((_BYTE *)v11 + v4) = a4;
  *((_BYTE *)v11 + v4 + 1) = 0;
  if ( v8 + 1 < 0x1000 )
  {
    j_j_free(v14);
    goto LABEL_22;
  }
  v15 = (_BYTE *)*((_QWORD *)v14 - 1);
  if ( (unsigned __int64)((_BYTE *)v14 - v15 - 8) > 0x1F )
LABEL_19:
    __fastfail(5u);
  j_j_free(v15);
LABEL_22:
  *Src = v11;
  return Src;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140009024) ----------------------------------------------------
void *__fastcall sub_140009024(__int64 a1, char a2)
{
  return sub_140008670(a1 - *(int *)(a1 - 4), a2);
}

//----- (0000000140009030) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_140009030(__int64 a1, __int64 a2)
{
  __int64 v3; // rbx
  _QWORD *v4; // rax

  *(_QWORD *)a1 = a2;
  v3 = a1 + 8;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v4 = operator new(0x20u);
  *v4 = v4;
  v4[1] = v4;
  *(_QWORD *)(v3 + 8) = v4;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = 0;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = 7;
  *(_QWORD *)(v3 + 56) = 8;
  *(_DWORD *)v3 = 1065353216;
  sub_140006510(v3 + 24, 0x10u, *(_QWORD *)(v3 + 8));
  return a1;
}

//----- (00000001400090C0) ----------------------------------------------------
void __fastcall sub_1400090C0(__int64 a1)
{
  __int64 v1; // rdx
  void *v3; // rcx
  _QWORD **v4; // rcx
  _QWORD *v5; // rcx
  _QWORD *v6; // rbx

  v1 = *(_QWORD *)(a1 + 24);
  if ( v1 )
  {
    if ( (unsigned __int64)(8 * ((*(_QWORD *)(a1 + 40) - v1) >> 3)) < 0x1000 )
    {
      v3 = *(void **)(a1 + 24);
    }
    else
    {
      v3 = *(void **)(v1 - 8);
      if ( (unsigned __int64)(v1 - (_QWORD)v3 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v3);
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
  }
  v4 = *(_QWORD ***)(a1 + 8);
  *v4[1] = 0;
  v5 = *v4;
  if ( v5 )
  {
    do
    {
      v6 = (_QWORD *)*v5;
      j_j_free(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  j_j_free(*(void **)(a1 + 8));
}

//----- (00000001400091C0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
_QWORD *__fastcall sub_1400091C0(HANDLE *a1, _QWORD *a2, const void *a3, size_t a4)
{
  void *v8; // rax
  void *v9; // rcx
  _QWORD *v10; // rax
  char *v11; // rbx
  const __m128i *v12; // rax
  const void *v13; // rdx
  void *v14; // rcx
  DWORD LastError; // ebx
  _QWORD v17[5]; // [rsp+38h] [rbp-D0h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+60h] [rbp-A8h] BYREF
  SIZE_T NumberOfBytesRead; // [rsp+A0h] [rbp-68h] BYREF
  __int128 lpBuffer; // [rsp+A8h] [rbp-60h]
  char *v21; // [rsp+B8h] [rbp-50h]

  NumberOfBytesRead = (SIZE_T)a2;
  lpBuffer = 0;
  v21 = 0;
  if ( a4 )
  {
    if ( a4 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001720();
    if ( a4 < 0x1000 )
    {
      v10 = operator new(a4);
    }
    else
    {
      if ( a4 + 39 < a4 )
        sub_140001180();
      v8 = operator new(a4 + 39);
      v9 = v8;
      if ( !v8 )
LABEL_13:
        __fastfail(5u);
      v10 = (_QWORD *)(((unsigned __int64)v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
    }
    *(_QWORD *)&lpBuffer = v10;
    v11 = (char *)v10 + a4;
    v21 = (char *)v10 + a4;
    memset(v10, 0, a4);
    *((_QWORD *)&lpBuffer + 1) = v11;
  }
  NumberOfBytesRead = 0;
  if ( !ReadProcessMemory(*a1, a3, (LPVOID)lpBuffer, a4, &NumberOfBytesRead) )
  {
    LastError = GetLastError();
    sub_140005A60(v17, "Failed to read process memory");
    sub_140001760((__int64)pExceptionObject, (__int64)v17, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v12 = sub_14000BAA0((const __m128i *)lpBuffer, (const __m128i *)(lpBuffer + NumberOfBytesRead), 0);
  v13 = (const void *)lpBuffer;
  *(_OWORD *)a2 = 0;
  a2[2] = 0;
  a2[3] = 0;
  sub_140005F50(a2, v13, (char *)v12 - (_BYTE *)v13);
  if ( (_QWORD)lpBuffer )
  {
    if ( (unsigned __int64)&v21[-lpBuffer] < 0x1000 )
    {
      v14 = (void *)lpBuffer;
    }
    else
    {
      v14 = *(void **)(lpBuffer - 8);
      if ( (unsigned __int64)(lpBuffer - (_QWORD)v14 - 8) > 0x1F )
        goto LABEL_13;
    }
    j_j_free(v14);
  }
  return a2;
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001720: using guessed type void __noreturn sub_140001720(void);

//----- (00000001400093B0) ----------------------------------------------------
// Hidden C++ exception states: #wind=3
CHAR *__fastcall sub_1400093B0(HANDLE *a1, CHAR *a2, const void *a3, size_t a4)
{
  size_t v8; // rcx
  void *v9; // rax
  void *v10; // rcx
  _QWORD *v11; // rax
  char *v12; // rbx
  size_t v13; // rdi
  size_t v14; // rbx
  unsigned __int64 v15; // rsi
  const void *v16; // r15
  size_t v17; // rcx
  void *v18; // rax
  WCHAR *v19; // rdi
  size_t v20; // rbx
  const WCHAR *v21; // r8
  int cbMultiByte; // ebx
  CHAR *v23; // rcx
  const WCHAR *v24; // r8
  WCHAR *v25; // rcx
  void *v26; // rcx
  DWORD LastError; // ebx
  _QWORD v29[5]; // [rsp+48h] [rbp-B8h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+70h] [rbp-90h] BYREF
  LPCWCH lpWideCharStr[2]; // [rsp+B0h] [rbp-50h] BYREF
  size_t v32; // [rsp+C0h] [rbp-40h]
  unsigned __int64 v33; // [rsp+C8h] [rbp-38h]
  LPVOID lpBuffer[2]; // [rsp+D0h] [rbp-30h]
  char *v35; // [rsp+E0h] [rbp-20h]
  SIZE_T NumberOfBytesRead; // [rsp+E8h] [rbp-18h] BYREF

  NumberOfBytesRead = (SIZE_T)a2;
  *(_OWORD *)lpBuffer = 0;
  v35 = 0;
  if ( a4 )
  {
    if ( a4 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001720(a1);
    if ( a4 < 0x1000 )
    {
      v11 = operator new(a4);
    }
    else
    {
      v8 = a4 + 39;
      if ( a4 + 39 < a4 )
        sub_140001180(v8);
      v9 = operator new(v8);
      v10 = v9;
      if ( !v9 )
LABEL_42:
        __fastfail(5u);
      v11 = (_QWORD *)(((unsigned __int64)v9 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v11 - 1) = v10;
    }
    lpBuffer[0] = v11;
    v12 = (char *)v11 + a4;
    v35 = (char *)v11 + a4;
    memset(v11, 0, a4);
    lpBuffer[1] = v12;
  }
  NumberOfBytesRead = 0;
  if ( !ReadProcessMemory(*a1, a3, lpBuffer[0], a4, &NumberOfBytesRead) )
  {
    LastError = GetLastError();
    sub_140005A60(v29, "Failed to read process memory");
    sub_140001760((__int64)pExceptionObject, (__int64)v29, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v13 = a4 >> 1;
  v14 = (int)v13;
  *(_OWORD *)lpWideCharStr = 0;
  v32 = 0;
  v33 = 0;
  v15 = 0x7FFFFFFFFFFFFFFELL;
  if ( (unsigned __int64)(int)v13 > 0x7FFFFFFFFFFFFFFELL )
    sub_140001740();
  v16 = lpBuffer[0];
  if ( (unsigned __int64)(int)v13 <= 7 )
  {
    v32 = (int)v13;
    v33 = 7;
    memcpy(lpWideCharStr, lpBuffer[0], 2LL * (int)v13);
    *((_WORD *)lpWideCharStr + (int)v13) = 0;
    goto LABEL_26;
  }
  if ( ((int)v13 | 7uLL) <= 0x7FFFFFFFFFFFFFFELL )
  {
    v15 = (int)v13 | 7LL;
    if ( v15 < 0xA )
      v15 = 10;
    v17 = v15 + 1;
    if ( v15 + 1 > 0x7FFFFFFFFFFFFFFFLL )
      goto LABEL_47;
    v17 *= 2LL;
    if ( !v17 )
    {
      v19 = 0;
      goto LABEL_25;
    }
  }
  else
  {
    v17 = -2;
  }
  if ( v17 >= 0x1000 )
  {
    if ( v17 + 39 >= v17 )
    {
      v18 = operator new(v17 + 39);
      if ( !v18 )
        goto LABEL_36;
      v19 = (WCHAR *)(((unsigned __int64)v18 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *((_QWORD *)v19 - 1) = v18;
      goto LABEL_25;
    }
LABEL_47:
    sub_140001180(v17);
  }
  v19 = (WCHAR *)operator new(v17);
LABEL_25:
  lpWideCharStr[0] = v19;
  v32 = v14;
  v33 = v15;
  v20 = v14;
  memcpy(v19, v16, v20 * 2);
  v19[v20] = 0;
LABEL_26:
  v21 = (const WCHAR *)lpWideCharStr;
  if ( v33 > 7 )
    v21 = lpWideCharStr[0];
  cbMultiByte = WideCharToMultiByte(0xFDE9u, 0, v21, -1, 0, 0, 0, 0);
  sub_140005950(a2, cbMultiByte - 1);
  if ( *((_QWORD *)a2 + 3) <= 0xFu )
    v23 = a2;
  else
    v23 = *(CHAR **)a2;
  v24 = (const WCHAR *)lpWideCharStr;
  if ( v33 > 7 )
    v24 = lpWideCharStr[0];
  WideCharToMultiByte(0xFDE9u, 0, v24, -1, v23, cbMultiByte, 0, 0);
  if ( v33 > 7 )
  {
    if ( 2 * v33 + 2 < 0x1000 )
    {
      v25 = (WCHAR *)lpWideCharStr[0];
    }
    else
    {
      v25 = (WCHAR *)*((_QWORD *)lpWideCharStr[0] - 1);
      if ( (unsigned __int64)((char *)lpWideCharStr[0] - (char *)v25 - 8) > 0x1F )
LABEL_36:
        __fastfail(5u);
    }
    j_j_free(v25);
  }
  v32 = 0;
  v33 = 7;
  LOWORD(lpWideCharStr[0]) = 0;
  if ( lpBuffer[0] )
  {
    if ( (unsigned __int64)(v35 - (char *)lpBuffer[0]) < 0x1000 )
    {
      v26 = lpBuffer[0];
    }
    else
    {
      v26 = (void *)*((_QWORD *)lpBuffer[0] - 1);
      if ( (unsigned __int64)((char *)lpBuffer[0] - (char *)v26 - 8) > 0x1F )
        goto LABEL_42;
    }
    j_j_free(v26);
  }
  return a2;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);
// 140001740: using guessed type void __noreturn sub_140001740(void);

//----- (0000000140009720) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
__int64 __fastcall sub_140009720(HANDLE *a1, const void *a2)
{
  DWORD LastError; // ebx
  _QWORD v4[4]; // [rsp+30h] [rbp-88h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+50h] [rbp-68h] BYREF
  unsigned int v6; // [rsp+90h] [rbp-28h] BYREF
  SIZE_T lpNumberOfBytesRead; // [rsp+98h] [rbp-20h] BYREF

  lpNumberOfBytesRead = 0;
  if ( !ReadProcessMemory(*a1, a2, &v6, 4u, &lpNumberOfBytesRead) )
  {
    LastError = GetLastError();
    sub_140005A60(v4, "Failed to read process memory");
    sub_140001760((__int64)pExceptionObject, (__int64)v4, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  return v6;
}

//----- (00000001400097D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
LPVOID __fastcall sub_1400097D0(__int64 a1, __int64 a2)
{
  SIZE_T v4; // rbx
  LPVOID v5; // rbx
  DWORD v7; // ebx
  DWORD LastError; // ebx
  _QWORD v9[8]; // [rsp+30h] [rbp-B8h] BYREF
  _BYTE pExceptionObject[64]; // [rsp+70h] [rbp-78h] BYREF
  LPVOID lpBaseAddress; // [rsp+B0h] [rbp-38h] BYREF
  SIZE_T NumberOfBytesWritten[4]; // [rsp+B8h] [rbp-30h] BYREF

  v4 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  lpBaseAddress = VirtualAllocEx(*(HANDLE *)a1, 0, v4, 0x1000u, 0x40u);
  if ( !lpBaseAddress )
  {
    LastError = GetLastError();
    sub_140005A60(NumberOfBytesWritten, "Failed to allocate process memory");
    sub_140001760((__int64)v9, (__int64)NumberOfBytesWritten, LastError);
    throw (LuoInjector::InjectorException *)v9;
  }
  *(_QWORD *)(*(_QWORD *)sub_140009D10(
                           (_QWORD *)(a1 + 8),
                           (__int64)NumberOfBytesWritten,
                           (unsigned __int8 *)&lpBaseAddress)
            + 24LL) = v4;
  v5 = lpBaseAddress;
  NumberOfBytesWritten[0] = 0;
  if ( !WriteProcessMemory(
          *(HANDLE *)a1,
          lpBaseAddress,
          *(LPCVOID *)a2,
          *(_QWORD *)(a2 + 8) - *(_QWORD *)a2,
          NumberOfBytesWritten) )
  {
    v7 = GetLastError();
    sub_140005A60(v9, "Failed to write process memory");
    sub_140001760((__int64)pExceptionObject, (__int64)v9, v7);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  return v5;
}

//----- (0000000140009940) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
LPVOID __fastcall sub_140009940(__int64 a1, const void **a2)
{
  _BYTE *v2; // rdi
  _BYTE *v4; // rax
  char *v5; // rbx
  size_t v6; // rbx
  size_t v7; // rcx
  void *v8; // rax
  void *v9; // rcx
  _QWORD *v10; // rax
  _BYTE *v11; // rsi
  LPVOID v12; // rbx
  void *v13; // r8
  char v15[8]; // [rsp+20h] [rbp-58h] BYREF
  __int128 v16; // [rsp+28h] [rbp-50h] BYREF
  char *v17; // [rsp+38h] [rbp-40h]

  v2 = a2;
  v4 = 0;
  v16 = 0;
  v17 = 0;
  if ( (unsigned __int64)a2[3] <= 0xF )
  {
    v5 = (char *)a2[2] + (_QWORD)a2;
  }
  else
  {
    v5 = (char *)*a2 + (_QWORD)a2[2];
    v2 = *a2;
  }
  v16 = 0;
  v17 = 0;
  v6 = v5 - v2;
  if ( v6 )
  {
    if ( v6 > 0x7FFFFFFFFFFFFFFFLL )
      sub_140001720(a1);
    if ( v6 < 0x1000 )
    {
      v10 = operator new(v6);
    }
    else
    {
      v7 = v6 + 39;
      if ( v6 + 39 < v6 )
        sub_140001180(v7);
      v8 = operator new(v7);
      v9 = v8;
      if ( !v8 )
LABEL_19:
        __fastfail(5u);
      v10 = (_QWORD *)(((unsigned __int64)v8 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
      *(v10 - 1) = v9;
    }
    *(_QWORD *)&v16 = v10;
    v11 = (char *)v10 + v6;
    v17 = (char *)v10 + v6;
    memmove(v10, v2, v6);
    *((_QWORD *)&v16 + 1) = v11;
    v4 = v17;
  }
  else
  {
    v11 = (_BYTE *)*((_QWORD *)&v16 + 1);
  }
  v15[0] = 0;
  if ( v11 == v4 )
  {
    sub_1400015A0(&v16, v11, v15);
  }
  else
  {
    *v11 = 0;
    ++*((_QWORD *)&v16 + 1);
  }
  v12 = sub_1400097D0(a1, (__int64)&v16);
  if ( (_QWORD)v16 )
  {
    if ( (unsigned __int64)&v17[-v16] < 0x1000 )
    {
      v13 = (void *)v16;
    }
    else
    {
      v13 = *(void **)(v16 - 8);
      if ( (unsigned __int64)(v16 - (_QWORD)v13 - 8) > 0x1F )
        goto LABEL_19;
    }
    j_j_free(v13);
  }
  return v12;
}
// 140001180: using guessed type void __fastcall __noreturn sub_140001180(_QWORD);
// 140001720: using guessed type void __fastcall __noreturn sub_140001720(_QWORD);

//----- (0000000140009AC0) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
LPVOID __fastcall sub_140009AC0(__int64 a1)
{
  _DWORD *v2; // rax
  LPVOID v3; // rbx
  void *v4; // r8
  _QWORD v6[2]; // [rsp+20h] [rbp-28h] BYREF
  _DWORD *v7; // [rsp+30h] [rbp-18h]

  v2 = operator new(4u);
  v6[0] = v2;
  v7 = v2 + 1;
  *v2 = 0;
  v6[1] = v2 + 1;
  *(_DWORD *)v6[0] = 0;
  v3 = sub_1400097D0(a1, (__int64)v6);
  if ( v6[0] )
  {
    if ( (unsigned __int64)v7 - v6[0] < 0x1000 )
    {
      v4 = (void *)v6[0];
    }
    else
    {
      v4 = *(void **)(v6[0] - 8LL);
      if ( (unsigned __int64)(v6[0] - (_QWORD)v4 - 8LL) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
  }
  return v3;
}

//----- (0000000140009B80) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
LPVOID __fastcall sub_140009B80(__int64 a1)
{
  _QWORD *v2; // rax
  LPVOID v3; // rbx
  void *v4; // r8
  _QWORD v6[2]; // [rsp+20h] [rbp-28h] BYREF
  _QWORD *v7; // [rsp+30h] [rbp-18h]

  v2 = operator new(8u);
  v6[0] = v2;
  v7 = v2 + 1;
  *v2 = 0;
  v6[1] = v2 + 1;
  *(_QWORD *)v6[0] = 0;
  v3 = sub_1400097D0(a1, (__int64)v6);
  if ( v6[0] )
  {
    if ( (unsigned __int64)v7 - v6[0] < 0x1000 )
    {
      v4 = (void *)v6[0];
    }
    else
    {
      v4 = *(void **)(v6[0] - 8LL);
      if ( (unsigned __int64)(v6[0] - (_QWORD)v4 - 8LL) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v4);
  }
  return v3;
}

//----- (0000000140009C40) ----------------------------------------------------
void __fastcall sub_140009C40(void **a1)
{
  _QWORD **v2; // rcx
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v2 = (_QWORD **)*a1;
  *v2[1] = 0;
  v3 = *v2;
  if ( v3 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      j_j_free(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  j_j_free(*a1);
}

//----- (0000000140009D10) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
__int64 __fastcall sub_140009D10(_QWORD *a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rdx
  __int64 v8; // r8
  _QWORD *v9; // rcx
  _QWORD *v10; // r12
  _QWORD *v11; // rbp
  _QWORD *v12; // rdx
  _QWORD *v14; // rbx
  __int64 v15; // rcx
  float v16; // xmm0_4
  unsigned __int64 v17; // rdi
  float v18; // xmm3_4
  float v19; // xmm2_4
  __int64 v20; // rcx
  float v21; // xmm0_4
  unsigned __int64 v22; // rcx
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rcx
  __int64 v25; // r8
  _QWORD *v26; // rcx
  _QWORD *v27; // r8
  __int64 v28; // rax
  _QWORD *v29; // rdx
  __int64 v30; // rcx
  __int64 v31; // rax
  _QWORD *v32; // r8

  v6 = 0x100000001B3LL
     * (a3[7]
      ^ (0x100000001B3LL
       * (a3[6]
        ^ (0x100000001B3LL
         * (a3[5]
          ^ (0x100000001B3LL
           * (a3[4]
            ^ (0x100000001B3LL
             * (a3[3]
              ^ (0x100000001B3LL
               * (a3[2] ^ (0x100000001B3LL * (a3[1] ^ (0x100000001B3LL * (*a3 ^ 0xCBF29CE484222325uLL)))))))))))))));
  v7 = a1[6] & v6;
  v8 = a1[3];
  v9 = *(_QWORD **)(v8 + 16 * v7 + 8);
  v10 = a1 + 1;
  v11 = (_QWORD *)a1[1];
  if ( v9 == v11 )
    goto LABEL_8;
  v12 = *(_QWORD **)(v8 + 16 * v7);
  if ( *(_QWORD *)a3 != v9[2] )
  {
    while ( v9 != v12 )
    {
      v9 = (_QWORD *)v9[1];
      if ( *(_QWORD *)a3 == v9[2] )
        goto LABEL_5;
    }
    v11 = v9;
LABEL_8:
    if ( a1[2] == 0x7FFFFFFFFFFFFFFLL )
      std::_Xlength_error("unordered_map/set too long");
    v14 = operator new(0x20u);
    v14[2] = *(_QWORD *)a3;
    v14[3] = 0;
    v15 = a1[2] + 1LL;
    if ( v15 < 0 )
      v16 = (float)(v15 & 1 | (unsigned int)((unsigned __int64)v15 >> 1))
          + (float)(v15 & 1 | (unsigned int)((unsigned __int64)v15 >> 1));
    else
      v16 = (float)(int)v15;
    v17 = a1[7];
    v18 = *(float *)a1;
    if ( (v17 & 0x8000000000000000uLL) != 0LL )
    {
      v20 = a1[7] & 1LL | (v17 >> 1);
      v19 = (float)(int)v20 + (float)(int)v20;
    }
    else
    {
      v19 = (float)(int)v17;
    }
    if ( (float)(v16 / v19) > v18 )
    {
      v21 = ceilf(v16 / v18);
      v22 = 0;
      if ( v21 >= 9.223372e18 )
      {
        v21 = v21 - 9.223372e18;
        if ( v21 < 9.223372e18 )
          v22 = 0x8000000000000000uLL;
      }
      v23 = v22 + (unsigned int)(int)v21;
      v24 = 8;
      if ( v23 > 8 )
        v24 = v23;
      if ( v17 < v24 )
      {
        if ( v17 >= 0x200 || (v17 *= 8LL, v17 < v24) )
          v17 = v24;
      }
      sub_140009FE0(a1, v17);
      v25 = a1[3];
      v26 = *(_QWORD **)(v25 + 16 * (a1[6] & v6) + 8);
      v11 = (_QWORD *)*v10;
      if ( v26 != (_QWORD *)*v10 )
      {
        v27 = *(_QWORD **)(v25 + 16 * (a1[6] & v6));
        v28 = v14[2];
        if ( v28 == v26[2] )
        {
LABEL_30:
          v11 = (_QWORD *)*v26;
        }
        else
        {
          while ( v26 != v27 )
          {
            v26 = (_QWORD *)v26[1];
            if ( v28 == v26[2] )
              goto LABEL_30;
          }
          v11 = v26;
        }
      }
    }
    v29 = (_QWORD *)v11[1];
    ++a1[2];
    *v14 = v11;
    v14[1] = v29;
    *v29 = v14;
    v11[1] = v14;
    v30 = a1[3];
    v31 = 2 * (v6 & a1[6]);
    v32 = *(_QWORD **)(v30 + 16 * (v6 & a1[6]));
    if ( v32 == (_QWORD *)*v10 )
    {
      *(_QWORD *)(v30 + 16 * (v6 & a1[6])) = v14;
LABEL_37:
      *(_QWORD *)(v30 + 8 * v31 + 8) = v14;
      goto LABEL_38;
    }
    if ( v32 == v11 )
    {
      *(_QWORD *)(v30 + 16 * (v6 & a1[6])) = v14;
    }
    else if ( *(_QWORD **)(v30 + 16 * (v6 & a1[6]) + 8) == v29 )
    {
      goto LABEL_37;
    }
LABEL_38:
    *(_QWORD *)a2 = v14;
    *(_BYTE *)(a2 + 8) = 1;
    return a2;
  }
LABEL_5:
  *(_QWORD *)a2 = v9;
  *(_BYTE *)(a2 + 8) = 0;
  return a2;
}
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (0000000140009FE0) ----------------------------------------------------
_QWORD *__fastcall sub_140009FE0(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rcx
  __int64 v6; // rdi
  _QWORD *result; // rax
  _QWORD *v8; // rcx
  _QWORD *i; // rdx
  _QWORD *v10; // r9
  _QWORD *v11; // rdi
  __int64 v12; // r8
  _QWORD *v13; // r10
  _QWORD *v14; // r9
  _QWORD *v15; // r8
  _QWORD *v16; // r10
  _QWORD *v17; // r9
  _QWORD *v18; // r8
  _QWORD *v19; // r10
  _QWORD *v20; // r9
  _QWORD *v21; // r8

  _BitScanReverse64(&v3, 0xFFFFFFFFFFFFFFFuLL);
  if ( a2 > 1LL << v3 )
    std::_Xlength_error("invalid hash bucket count");
  v4 = a1[1];
  _BitScanReverse64(&v5, (a2 - 1) | 1);
  v6 = 1LL << ((unsigned __int8)v5 + 1);
  sub_140006510((__int64)(a1 + 3), 2 * v6, v4);
  a1[7] = v6;
  result = (_QWORD *)(v6 - 1);
  a1[6] = v6 - 1;
  v8 = *(_QWORD **)a1[1];
  for ( i = v8; i != (_QWORD *)v4; v8 = i )
  {
    i = (_QWORD *)*i;
    result = (_QWORD *)a1[3];
    v10 = (_QWORD *)result[2
                         * (a1[6]
                          & (0x100000001B3LL
                           * (*((unsigned __int8 *)v8 + 23)
                            ^ (0x100000001B3LL
                             * (*((unsigned __int8 *)v8 + 22)
                              ^ (0x100000001B3LL
                               * (*((unsigned __int8 *)v8 + 21)
                                ^ (0x100000001B3LL
                                 * (*((unsigned __int8 *)v8 + 20)
                                  ^ (0x100000001B3LL
                                   * (*((unsigned __int8 *)v8 + 19)
                                    ^ (0x100000001B3LL
                                     * (*((unsigned __int8 *)v8 + 18)
                                      ^ (0x100000001B3LL
                                       * (*((unsigned __int8 *)v8 + 17)
                                        ^ (0x100000001B3LL * (*((unsigned __int8 *)v8 + 16) ^ 0xCBF29CE484222325uLL)))))))))))))))))];
    v11 = &result[2
                * (a1[6]
                 & (0x100000001B3LL
                  * (*((unsigned __int8 *)v8 + 23)
                   ^ (0x100000001B3LL
                    * (*((unsigned __int8 *)v8 + 22)
                     ^ (0x100000001B3LL
                      * (*((unsigned __int8 *)v8 + 21)
                       ^ (0x100000001B3LL
                        * (*((unsigned __int8 *)v8 + 20)
                         ^ (0x100000001B3LL
                          * (*((unsigned __int8 *)v8 + 19)
                           ^ (0x100000001B3LL
                            * (*((unsigned __int8 *)v8 + 18)
                             ^ (0x100000001B3LL
                              * (*((unsigned __int8 *)v8 + 17)
                               ^ (0x100000001B3LL * (*((unsigned __int8 *)v8 + 16) ^ 0xCBF29CE484222325uLL)))))))))))))))))];
    if ( v10 == (_QWORD *)v4 )
    {
      *v11 = v8;
      v11[1] = v8;
    }
    else
    {
      result = (_QWORD *)v11[1];
      v12 = v8[2];
      if ( v12 == result[2] )
      {
        v13 = (_QWORD *)*result;
        if ( (_QWORD *)*result != v8 )
        {
          v14 = (_QWORD *)v8[1];
          *v14 = i;
          v15 = (_QWORD *)i[1];
          *v15 = v13;
          result = (_QWORD *)v13[1];
          *result = v8;
          v13[1] = v15;
          i[1] = v14;
          v8[1] = result;
        }
        v11[1] = v8;
      }
      else if ( v10 == result )
      {
LABEL_13:
        v16 = (_QWORD *)v8[1];
        *v16 = i;
        v17 = (_QWORD *)i[1];
        *v17 = result;
        v18 = (_QWORD *)result[1];
        *v18 = v8;
        result[1] = v17;
        i[1] = v16;
        v8[1] = v18;
        *v11 = v8;
      }
      else
      {
        while ( 1 )
        {
          result = (_QWORD *)result[1];
          if ( v12 == result[2] )
            break;
          if ( v10 == result )
            goto LABEL_13;
        }
        v19 = (_QWORD *)*result;
        v20 = (_QWORD *)v8[1];
        *v20 = i;
        v21 = (_QWORD *)i[1];
        *v21 = v19;
        result = (_QWORD *)v19[1];
        *result = v8;
        v19[1] = v21;
        i[1] = v20;
        v8[1] = result;
      }
    }
  }
  return result;
}
// 14000E230: using guessed type void __noreturn std::_Xlength_error(const char *);

//----- (000000014000A1D0) ----------------------------------------------------
// Hidden C++ exception states: #wind=7 #try_helpers=1
__int64 __fastcall sub_14000A1D0(__int64 a1, void *a2, __int64 a3)
{
  int v6; // r14d
  _QWORD *v7; // rax
  __int64 v8; // rbx
  bool v9; // al
  _BOOL8 v10; // rbx
  __int64 v11; // r13
  SIZE_T v12; // rbx
  HANDLE *v13; // rsi
  int v14; // r12d
  SIZE_T v15; // rsi
  __int64 v16; // rbx
  void *v17; // rcx
  __int64 *v18; // rsi
  __int64 *i; // rbx
  DWORD LastError; // ebx
  DWORD v22; // ebx
  DWORD v23; // ebx
  DWORD v24; // ebx
  DWORD v25; // ebx
  DWORD v26; // ebx
  DWORD v27; // ebx
  DWORD v28; // ebx
  DWORD v29; // ebx
  HANDLE hProcess[2]; // [rsp+40h] [rbp-378h] BYREF
  __int128 v31; // [rsp+50h] [rbp-368h]
  __int128 v32; // [rsp+60h] [rbp-358h] BYREF
  __int128 v33; // [rsp+70h] [rbp-348h]
  __int64 v34; // [rsp+80h] [rbp-338h]
  HANDLE *v35; // [rsp+90h] [rbp-328h]
  __int64 v36; // [rsp+98h] [rbp-320h]
  _BYTE pExceptionObject[64]; // [rsp+A0h] [rbp-318h] BYREF
  _BYTE v38[64]; // [rsp+E0h] [rbp-2D8h] BYREF
  _BYTE v39[64]; // [rsp+120h] [rbp-298h] BYREF
  _BYTE v40[64]; // [rsp+160h] [rbp-258h] BYREF
  _BYTE v41[64]; // [rsp+1A0h] [rbp-218h] BYREF
  _BYTE v42[64]; // [rsp+1E0h] [rbp-1D8h] BYREF
  _BYTE v43[64]; // [rsp+220h] [rbp-198h] BYREF
  _BYTE v44[64]; // [rsp+260h] [rbp-158h] BYREF
  _BYTE v45[64]; // [rsp+2A0h] [rbp-118h] BYREF
  int Buffer; // [rsp+2E0h] [rbp-D8h] BYREF
  BOOL Wow64Process; // [rsp+2E4h] [rbp-D4h] BYREF
  SIZE_T v48; // [rsp+2E8h] [rbp-D0h] BYREF
  SIZE_T NumberOfBytesRead; // [rsp+2F0h] [rbp-C8h] BYREF
  _QWORD v50[3]; // [rsp+2F8h] [rbp-C0h] BYREF
  unsigned __int64 v51; // [rsp+310h] [rbp-A8h]
  int v52; // [rsp+318h] [rbp-A0h] BYREF
  int v53; // [rsp+31Ch] [rbp-9Ch] BYREF
  int v54; // [rsp+320h] [rbp-98h] BYREF
  SIZE_T lpNumberOfBytesRead; // [rsp+328h] [rbp-90h] BYREF
  SIZE_T v56; // [rsp+330h] [rbp-88h] BYREF
  SIZE_T v57; // [rsp+338h] [rbp-80h] BYREF
  SIZE_T v58; // [rsp+340h] [rbp-78h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [rsp+348h] [rbp-70h] BYREF

  v36 = a1;
  v6 = 0;
  *(_OWORD *)a1 = 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  hProcess[0] = a2;
  v35 = &hProcess[1];
  hProcess[1] = 0;
  v31 = 0u;
  v7 = operator new(0x20u);
  *v7 = v7;
  v7[1] = v7;
  *(_QWORD *)&v31 = v7;
  v32 = 0;
  *(_QWORD *)&v33 = 0;
  *((_QWORD *)&v33 + 1) = 7;
  v34 = 8;
  LODWORD(hProcess[1]) = 1065353216;
  sub_140006510((__int64)&v32, 0x10u, (unsigned __int64)v7);
  NumberOfBytesRead = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(a3 + 60), &Buffer, 4u, &NumberOfBytesRead) )
  {
    LastError = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)pExceptionObject, (__int64)v50, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v8 = a3 + Buffer;
  GetSystemInfo(&SystemInfo);
  v9 = SystemInfo.wProcessorArchitecture == 9 && (!IsWow64Process(a2, &Wow64Process) || !Wow64Process);
  lpNumberOfBytesRead = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(v8 + 16LL * v9 + 120), &Wow64Process, 4u, &lpNumberOfBytesRead) )
  {
    v22 = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)v38, (__int64)v50, v22);
    throw (LuoInjector::InjectorException *)v38;
  }
  v10 = Wow64Process;
  v56 = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(a3 + Wow64Process + 32LL), &v52, 4u, &v56) )
  {
    v23 = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)v39, (__int64)v50, v23);
    throw (LuoInjector::InjectorException *)v39;
  }
  v57 = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(a3 + v10 + 36), &v53, 4u, &v57) )
  {
    v24 = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)v40, (__int64)v50, v24);
    throw (LuoInjector::InjectorException *)v40;
  }
  v58 = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(a3 + v10 + 28), &v54, 4u, &v58) )
  {
    v25 = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)v41, (__int64)v50, v25);
    throw (LuoInjector::InjectorException *)v41;
  }
  NumberOfBytesRead = 0;
  if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(a3 + v10 + 24), &Buffer, 4u, &NumberOfBytesRead) )
  {
    v26 = GetLastError();
    sub_140005A60(v50, "Failed to read process memory");
    sub_140001760((__int64)v42, (__int64)v50, v26);
    throw (LuoInjector::InjectorException *)v42;
  }
  v11 = a3 + v52;
  v12 = a3 + v53;
  NumberOfBytesRead = v12;
  v13 = (HANDLE *)(a3 + v54);
  v35 = v13;
  v14 = Buffer;
  while ( v6 < v14 )
  {
    v48 = 0;
    if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(v11 + 4 * v6), &Wow64Process, 4u, &v48) )
    {
      v27 = GetLastError();
      sub_140005A60(&SystemInfo, "Failed to read process memory");
      sub_140001760((__int64)v43, (__int64)&SystemInfo, v27);
      throw (LuoInjector::InjectorException *)v43;
    }
    sub_1400091C0(hProcess, v50, (const void *)(a3 + Wow64Process), 0x20u);
    v48 = 0;
    if ( !ReadProcessMemory(hProcess[0], (LPCVOID)(v12 + 2 * v6), &Buffer, 2u, &v48) )
    {
      v28 = GetLastError();
      sub_140005A60(&SystemInfo, "Failed to read process memory");
      sub_140001760((__int64)v44, (__int64)&SystemInfo, v28);
      throw (LuoInjector::InjectorException *)v44;
    }
    v48 = 0;
    if ( !ReadProcessMemory(hProcess[0], (char *)v13 + 4 * (__int16)Buffer, &lpNumberOfBytesRead, 4u, &v48) )
    {
      v29 = GetLastError();
      sub_140005A60(&SystemInfo, "Failed to read process memory");
      sub_140001760((__int64)v45, (__int64)&SystemInfo, v29);
      throw (LuoInjector::InjectorException *)v45;
    }
    v15 = a3 + (int)lpNumberOfBytesRead;
    v48 = v15;
    if ( v15 )
    {
      v16 = *(_QWORD *)(a1 + 8);
      if ( v16 == *(_QWORD *)(a1 + 16) )
      {
        sub_14000AD60(a1, *(_QWORD *)(a1 + 8), (__int64)v50, (__int64 *)&v48);
      }
      else
      {
        sub_140001E00(*(_QWORD *)(a1 + 8), (__int64)v50);
        *(_QWORD *)(v16 + 32) = v15;
        *(_QWORD *)(a1 + 8) += 40LL;
      }
      v12 = NumberOfBytesRead;
    }
    if ( v51 > 0xF )
    {
      v17 = (void *)v50[0];
      if ( v51 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)(v50[0] - *(_QWORD *)(v50[0] - 8LL) - 8LL) > 0x1F )
          __fastfail(5u);
        v17 = *(void **)(v50[0] - 8LL);
      }
      j_j_free(v17);
    }
    ++v6;
    v13 = v35;
  }
  v18 = (__int64 *)v31;
  for ( i = *(__int64 **)v31; i != v18; i = (__int64 *)*i )
    VirtualFreeEx(hProcess[0], (LPVOID)i[2], 0, 0x8000u);
  sub_1400090C0((__int64)&hProcess[1]);
  return a1;
}

//----- (000000014000A980) ----------------------------------------------------
// Hidden C++ exception states: #wind=2
char __fastcall sub_14000A980(void *a1, HMODULE *a2)
{
  DWORD v3; // r12d
  __int64 v4; // r14
  HMODULE *v5; // r15
  size_t v6; // rax
  void **v7; // rsi
  void **v8; // rcx
  unsigned __int64 v9; // rdx
  void **v10; // rbx
  unsigned __int64 v11; // r8
  void **v12; // rbx
  void **v13; // rdi
  void **v14; // rdi
  char *v15; // rbx
  __int64 v16; // rax
  char **v17; // rsi
  char **v18; // rbx
  char **v19; // rdi
  char **v20; // rcx
  void *v21; // rax
  void *v23; // rax
  void *v24; // rcx
  DWORD LastError; // ebx
  _BYTE pExceptionObject[64]; // [rsp+40h] [rbp-C0h] BYREF
  void *Block[2]; // [rsp+80h] [rbp-80h] BYREF
  unsigned __int64 v29; // [rsp+90h] [rbp-70h]
  unsigned __int64 v30; // [rsp+98h] [rbp-68h]
  DWORD cbNeeded; // [rsp+A0h] [rbp-60h] BYREF
  void *Buf1[2]; // [rsp+A8h] [rbp-58h] BYREF
  __int64 v33; // [rsp+B8h] [rbp-48h]
  HMODULE hModule[1024]; // [rsp+D0h] [rbp-30h] BYREF
  CHAR Filename[272]; // [rsp+20D0h] [rbp+1FD0h] BYREF

  if ( !K32EnumProcessModulesEx(a1, hModule, 0x2000u, &cbNeeded, 3u) )
  {
    LastError = GetLastError();
    sub_140005A60(Buf1, "Failed to enumerate process modules");
    sub_140001760((__int64)pExceptionObject, (__int64)Buf1, LastError);
    throw (LuoInjector::InjectorException *)pExceptionObject;
  }
  v3 = cbNeeded >> 3;
  v4 = 0;
  if ( !(cbNeeded >> 3) )
    return 0;
  while ( 1 )
  {
    v5 = &hModule[v4];
    if ( K32GetModuleFileNameExA(a1, *v5, Filename, 0x104u) )
      break;
LABEL_37:
    v4 = (unsigned int)(v4 + 1);
    if ( (unsigned int)v4 >= v3 )
      return 0;
  }
  *(_OWORD *)Block = 0;
  v29 = 0;
  v30 = 0;
  v6 = strlen(Filename);
  sub_140005F50(Block, Filename, v6);
  v7 = Block;
  v8 = (void **)Block[0];
  v9 = v30;
  if ( v30 > 0xF )
    v7 = (void **)Block[0];
  v10 = Block;
  if ( v30 > 0xF )
    v10 = (void **)Block[0];
  v11 = v29;
  v12 = (void **)((char *)v10 + v29);
  v13 = Block;
  if ( v30 > 0xF )
    v13 = (void **)Block[0];
  if ( v13 != v12 )
  {
    do
    {
      *(_BYTE *)v7 = tolower(*(unsigned __int8 *)v13);
      v7 = (void **)((char *)v7 + 1);
      v13 = (void **)((char *)v13 + 1);
    }
    while ( v13 != v12 );
    v9 = v30;
    v11 = v29;
    v8 = (void **)Block[0];
  }
  v14 = Block;
  if ( v9 > 0xF )
    v14 = v8;
  if ( v11 < 4 )
  {
LABEL_32:
    if ( v9 > 0xF )
    {
      if ( v9 + 1 >= 0x1000 )
      {
        if ( (unsigned __int64)((char *)v8 - (_BYTE *)*(v8 - 1) - 8) > 0x1F )
          goto LABEL_52;
        v8 = (void **)*(v8 - 1);
      }
      j_j_free(v8);
    }
    goto LABEL_37;
  }
  v15 = (char *)v14 + v11;
  v16 = sub_14000BAB0(v14, (char *)v14 + v11, "mono", 4);
  if ( (char *)v16 == v15 || v16 - (_QWORD)v14 == -1 )
  {
LABEL_31:
    v8 = (void **)Block[0];
    v9 = v30;
    goto LABEL_32;
  }
  *(_OWORD *)Buf1 = 0;
  v33 = 0;
  sub_14000A1D0((__int64)Buf1, a1, (__int64)*v5);
  v17 = (char **)Buf1[0];
  v18 = (char **)Buf1[0];
  v19 = (char **)Buf1[1];
  if ( Buf1[0] == Buf1[1] )
  {
LABEL_25:
    if ( v17 )
    {
      sub_1400062C0(v17, v19);
      if ( (unsigned __int64)(8 * ((signed __int64)(v33 - (unsigned __int64)Buf1[0]) >> 3)) < 0x1000 )
      {
        v21 = Buf1[0];
      }
      else
      {
        v21 = (void *)*((_QWORD *)Buf1[0] - 1);
        if ( (unsigned __int64)((char *)Buf1[0] - (char *)v21 - 8) > 0x1F )
          goto LABEL_51;
      }
      j_j_free(v21);
    }
    goto LABEL_31;
  }
  while ( 1 )
  {
    v20 = (unsigned __int64)v18[3] <= 0xF ? v18 : (char **)*v18;
    if ( v18[2] == (char *)20 && !memcmp(v20, "mono_get_root_domain", 0x14u) )
      break;
    v18 += 5;
    if ( v18 == v19 )
      goto LABEL_25;
  }
  *a2 = *v5;
  if ( v17 )
  {
    sub_1400062C0(v17, v19);
    if ( (unsigned __int64)(8 * ((signed __int64)(v33 - (unsigned __int64)Buf1[0]) >> 3)) < 0x1000 )
    {
      v23 = Buf1[0];
    }
    else
    {
      v23 = (void *)*((_QWORD *)Buf1[0] - 1);
      if ( (unsigned __int64)((char *)Buf1[0] - (char *)v23 - 8) > 0x1F )
LABEL_51:
        __fastfail(5u);
    }
    j_j_free(v23);
    *(_OWORD *)Buf1 = 0;
    v33 = 0;
  }
  if ( v30 <= 0xF )
    return 1;
  if ( v30 + 1 < 0x1000 )
  {
    j_j_free(Block[0]);
    return 1;
  }
  v24 = (void *)*((_QWORD *)Block[0] - 1);
  if ( (unsigned __int64)((char *)Block[0] - (char *)v24 - 8) > 0x1F )
LABEL_52:
    __fastfail(5u);
  j_j_free(v24);
  return 1;
}
// 14000BAB0: using guessed type __int64 __fastcall sub_14000BAB0(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000014000AD60) ----------------------------------------------------
// Hidden C++ exception states: #wind=1
char *__fastcall sub_14000AD60(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  char **v6; // rdi
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r8
  unsigned __int64 v10; // r13
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rbp
  _QWORD *v13; // r14
  void *v14; // rax
  __int64 v15; // r12
  __int64 v16; // rbx
  char **v17; // r8
  char **v18; // rdx
  _QWORD *v19; // rcx
  __int64 v20; // rbx
  __int64 v21; // rdx
  char *i; // rcx
  char **v23; // rcx
  char **v24; // rax

  v6 = *(char ***)a1;
  v7 = 0xCCCCCCCCCCCCCCCDuLL * ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  if ( v7 == 0x666666666666666LL )
    sub_140001720();
  v8 = 0xCCCCCCCCCCCCCCCDuLL * ((__int64)(*(_QWORD *)(a1 + 16) - (_QWORD)v6) >> 3);
  v9 = v8 >> 1;
  if ( v8 > 0x666666666666666LL - (v8 >> 1) )
    goto LABEL_31;
  v10 = v7 + 1;
  v11 = v7 + 1;
  if ( v8 + v9 >= v7 + 1 )
    v11 = v8 + v9;
  if ( v11 > 0x666666666666666LL )
    goto LABEL_31;
  v12 = 40 * v11;
  if ( !(40 * v11) )
  {
    v13 = 0;
    goto LABEL_14;
  }
  if ( v12 < 0x1000 )
  {
    v13 = operator new(40 * v11);
    goto LABEL_14;
  }
  if ( v12 + 39 < v12 )
LABEL_31:
    sub_140001180();
  v14 = operator new(v12 + 39);
  if ( !v14 )
    __fastfail(5u);
  v13 = (_QWORD *)(((unsigned __int64)v14 + 39) & 0xFFFFFFFFFFFFFFE0uLL);
  *(v13 - 1) = v14;
LABEL_14:
  v15 = (a2 - (__int64)v6) / 40;
  v16 = *a4;
  sub_140001E00((__int64)&v13[5 * v15], a3);
  v13[5 * v15 + 4] = v16;
  v17 = *(char ***)(a1 + 8);
  v18 = *(char ***)a1;
  v19 = v13;
  if ( (char **)a2 == v17 )
  {
    for ( ; v18 != v17; v18 += 5 )
    {
      *(_OWORD *)v19 = 0;
      v19[2] = 0;
      v19[3] = 0;
      *(_OWORD *)v19 = *(_OWORD *)v18;
      *((_OWORD *)v19 + 1) = *((_OWORD *)v18 + 1);
      v18[2] = 0;
      v18[3] = (char *)15;
      *(_BYTE *)v18 = 0;
      v19[4] = v18[4];
      v19 += 5;
    }
    sub_1400062C0((char **)v19, (char **)v19);
    v20 = 5 * v15;
  }
  else
  {
    for ( ; v18 != (char **)a2; v18 += 5 )
    {
      *(_OWORD *)v19 = 0;
      v19[2] = 0;
      v19[3] = 0;
      *(_OWORD *)v19 = *(_OWORD *)v18;
      *((_OWORD *)v19 + 1) = *((_OWORD *)v18 + 1);
      v18[2] = 0;
      v18[3] = (char *)15;
      *(_BYTE *)v18 = 0;
      v19[4] = v18[4];
      v19 += 5;
    }
    sub_1400062C0((char **)v19, (char **)v19);
    v20 = 5 * v15;
    v21 = *(_QWORD *)(a1 + 8);
    for ( i = (char *)&v13[5 * v15 + 5]; a2 != v21; a2 += 40 )
    {
      *(_OWORD *)i = 0;
      *((_QWORD *)i + 2) = 0;
      *((_QWORD *)i + 3) = 0;
      *(_OWORD *)i = *(_OWORD *)a2;
      *((_OWORD *)i + 1) = *(_OWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = 0;
      *(_QWORD *)(a2 + 24) = 15;
      *(_BYTE *)a2 = 0;
      *((_QWORD *)i + 4) = *(_QWORD *)(a2 + 32);
      i += 40;
    }
    sub_1400062C0((char **)i, (char **)i);
  }
  if ( *(_QWORD *)a1 )
  {
    sub_1400062C0(*(char ***)a1, *(char ***)(a1 + 8));
    v23 = *(char ***)a1;
    if ( (unsigned __int64)(8 * ((__int64)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3)) < 0x1000 )
    {
      v24 = *(char ***)a1;
    }
    else
    {
      v24 = (char **)*(v23 - 1);
      if ( (unsigned __int64)((char *)v23 - (char *)v24 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v24);
  }
  *(_QWORD *)a1 = v13;
  *(_QWORD *)(a1 + 8) = &v13[5 * v10];
  *(_QWORD *)(a1 + 16) = &v13[v12 / 8];
  return (char *)&v13[v20];
}
// 140001180: using guessed type void __noreturn sub_140001180(void);
// 140001720: using guessed type void __noreturn sub_140001720(void);

//----- (000000014000B150) ----------------------------------------------------
__int64 __fastcall sub_14000B150(const __m128i *Src, size_t Size, __m128i *a3, unsigned __int64 a4)
{
  int v10; // eax
  unsigned int v26; // edx
  __m128i *i; // rcx
  __int64 v28; // rax
  __int64 v29; // rax
  __m128i *j; // rcx
  __int64 v32; // rax
  __int64 v33; // rax
  __m256 v34; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v34 & 0xFFFFFFFFFFFFFFE0uLL;
  _RBX = Size;
  _RSI = Src;
  if ( (dword_14001500C & 4) != 0 )
  {
    LOBYTE(v10) = sub_14000B810(Size, a4, (dword_14001500C & 0x20) != 0);
    if ( v10 == 2 )
    {
      sub_14000B6B0(a3->m128i_i8, a4);
      __asm
      {
        vmovdqu ymm2, ymm0
        vmovdqu [rbp+250h+var_250], ymm0
      }
      if ( _RBX < 8 )
      {
LABEL_7:
        if ( !(_DWORD)_RBX )
          goto LABEL_11;
        __asm { vzeroupper }
        memcpy((void *)(_RBP + 544), _RSI, (unsigned int)_RBX);
        __asm
        {
          vpmovzxbd ymm3, [rbp+250h+var_30]
          vpandn  ymm0, ymm3, cs:ymmword_140010A80
          vpsrld  ymm1, ymm3, 5
          vpermd  ymm2, ymm1, [rbp+250h+var_250]
        }
        __asm
        {
          vpsllvd ymm1, ymm2, ymm0
          vmovmskps edx, ymm1
        }
        v26 = ((1 << _RBX) - 1) & _EDX;
        if ( v26 )
        {
          _RBX = 31 - __lzcnt(v26);
          __asm { vzeroupper }
        }
        else
        {
LABEL_11:
          _RBX = -1;
          __asm { vzeroupper }
        }
      }
      else
      {
        __asm { vmovdqu ymm4, cs:ymmword_140010A80 }
        while ( 1 )
        {
          __asm { vpmovzxbd ymm3, qword ptr [rsi+rbx-8] }
          _RBX -= 8LL;
          __asm
          {
            vpsrld  ymm0, ymm3, 5
            vpermd  ymm2, ymm0, ymm2
            vpandn  ymm1, ymm3, ymm4
            vpsllvd ymm2, ymm2, ymm1
            vmovmskps eax, ymm2
          }
          if ( _EAX )
            break;
          __asm { vmovdqu ymm2, [rbp+250h+var_250] }
          if ( _RBX < 8 )
            goto LABEL_7;
        }
        __asm { vzeroupper }
        return _RBX - __lzcnt(_EAX) + 31;
      }
      return _RBX;
    }
    if ( v10 != 1 )
      return sub_14000B490(_RSI, _RBX, a3, a4);
    memset((void *)(_RBP + 32), 0, 0x100u);
    for ( i = (__m128i *)((char *)a3 + a4); a3 != i; *(_BYTE *)(_RBP + 32 + v28) = 1 )
    {
      v28 = a3->m128i_u8[0];
      a3 = (__m128i *)((char *)a3 + 1);
    }
    if ( _RBX )
    {
      while ( 1 )
      {
        v29 = _RSI->m128i_u8[--_RBX];
        if ( *(_BYTE *)(_RBP + 32 + v29) )
          break;
        if ( !_RBX )
          return -1;
      }
      return _RBX;
    }
  }
  else
  {
    memset((void *)(_RBP + 288), 0, 0x100u);
    for ( j = (__m128i *)((char *)a3 + a4); a3 != j; *(_BYTE *)(_RBP + 288 + v32) = 1 )
    {
      v32 = a3->m128i_u8[0];
      a3 = (__m128i *)((char *)a3 + 1);
    }
    if ( _RBX )
    {
      while ( 1 )
      {
        v33 = _RSI->m128i_u8[--_RBX];
        if ( *(_BYTE *)(_RBP + 288 + v33) )
          break;
        if ( !_RBX )
          return -1;
      }
      return _RBX;
    }
  }
  return -1;
}
// 14000B211: masking with 0x7 was optimized away because ebx.4 <= 0x7
// 14000B1AB: variable 'v10' is possibly undefined
// 14001500C: using guessed type int dword_14001500C;

//----- (000000014000B390) ----------------------------------------------------
const __m128i *__fastcall sub_14000B390(const __m128i *a1, const __m128i *a2, unsigned __int8 a3)
{
  signed __int64 v5; // r9
  const __m128i *v7; // r10
  unsigned int v14; // r9d
  unsigned __int64 v22; // r9
  const __m128i *v23; // r10
  __m128i v24; // xmm1
  __int64 v25; // rax

  v5 = (char *)a2 - (char *)a1;
  if ( (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL) != 0 && (dword_14001500C & 0x20) != 0 )
  {
    _EAX = (char)a3;
    v7 = (const __m128i *)((char *)a1 + (((char *)a2 - (char *)a1) & 0xFFFFFFFFFFFFFFE0uLL));
    __asm
    {
      vmovd   xmm3, eax
      vpxor   xmm0, xmm0, xmm0
      vpshufb xmm3, xmm3, xmm0
      vinsertf128 ymm3, ymm3, xmm3, 1
    }
    do
    {
      __asm
      {
        vpcmpeqb ymm1, ymm3, ymmword ptr [rcx]
        vpmovmskb eax, ymm1
      }
      if ( _EAX )
        goto LABEL_14;
      a1 += 2;
    }
    while ( a1 != v7 );
    v14 = v5 & 0x1C;
    if ( !v14 )
    {
LABEL_9:
      __asm { vzeroupper }
      goto LABEL_10;
    }
    _RAX = (char *)&unk_140010A50 - v14;
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rax]
      vpmaskmovd ymm0, ymm2, ymmword ptr [rcx]
      vpcmpeqb ymm1, ymm0, ymm3
      vpand   ymm2, ymm1, ymm2
      vpmovmskb eax, ymm2
    }
    if ( !_EAX )
    {
      a1 = (const __m128i *)((char *)a1 + v14);
      goto LABEL_9;
    }
LABEL_14:
    __asm
    {
      vzeroupper
      tzcnt   eax, eax
    }
    return (const __m128i *)((char *)a1 + _EAX);
  }
  else
  {
    v22 = v5 & 0xFFFFFFFFFFFFFFF0uLL;
    if ( v22 && (dword_14001500C & 4) != 0 )
    {
      v23 = (const __m128i *)((char *)a1 + v22);
      v24 = _mm_shuffle_epi8(_mm_cvtsi32_si128(a3), (__m128i)0LL);
      while ( 1 )
      {
        LODWORD(v25) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v24));
        if ( (_DWORD)v25 )
          break;
        if ( ++a1 == v23 )
          goto LABEL_10;
      }
      _BitScanForward((unsigned int *)&v25, v25);
      return (const __m128i *)((char *)a1 + v25);
    }
    else
    {
LABEL_10:
      while ( a1 != a2 )
      {
        if ( a1->m128i_i8[0] == a3 )
          break;
        a1 = (const __m128i *)((char *)a1 + 1);
      }
      return a1;
    }
  }
}
// 14000B47E: variable 'v25' is possibly undefined
// 14001500C: using guessed type int dword_14001500C;

//----- (000000014000B490) ----------------------------------------------------
__int64 __fastcall sub_14000B490(const __m128i *Src, size_t Size, const __m128i *a3, size_t a4)
{
  size_t v4; // r15
  const __m128i *v5; // rbx
  unsigned int v6; // ebp
  const __m128i *v7; // rsi
  int v10; // edi
  __int8 *v11; // r12
  __m128i si128; // xmm6
  __m128i v13; // xmm0
  int v14; // ecx
  __m128i v15; // xmm0
  int v17; // ecx
  unsigned int v18; // ebp
  const __m128i *v19; // r14
  __m128i v20; // xmm6
  __m128i v21; // xmm1
  int v22; // r9d
  const __m128i *v23; // r8
  __m128i v24; // xmm0
  int v25; // ecx
  int v26; // ecx
  __m128i v27; // xmm1
  __m128i v28; // xmm0
  int v29; // ecx
  int v30; // ecx
  size_t Sizea[2]; // [rsp+20h] [rbp-88h] BYREF
  __m128i v32; // [rsp+30h] [rbp-78h] BYREF

  Sizea[0] = Size;
  v4 = Size & 0xF;
  v5 = (const __m128i *)((char *)Src + Size);
  v6 = a4;
  v7 = a3;
  v10 = -1;
  v11 = &Src->m128i_i8[v4];
  if ( a4 <= 0x10 )
  {
    memcpy(Sizea, a3, a4);
    si128 = _mm_load_si128((const __m128i *)Sizea);
    while ( v5 != (const __m128i *)v11 )
    {
      v13 = _mm_loadu_si128(--v5);
      v14 = _mm_cmpestri(si128, v13, v6, 0x10u);
      if ( _mm_cmpestrc(si128, v13, v6, 0x10u) )
        return (char *)v5 - (char *)Src + v14;
    }
    if ( v4 )
    {
      if ( Size < 0x10 )
      {
        memcpy(Sizea, Src, Size);
        v15 = _mm_load_si128((const __m128i *)Sizea);
      }
      else
      {
        v15 = _mm_loadu_si128(Src);
      }
      v17 = _mm_cmpestri(si128, v15, v6, v4);
      if ( _mm_cmpestrc(si128, v15, v6, v4) )
        return v17;
    }
    return -1;
  }
  v18 = a4 & 0xF;
  v19 = (const __m128i *)((char *)a3 + (a4 & 0xFFFFFFFFFFFFFFF0uLL));
  memcpy(&v32, v19, a4 & 0xF);
  v20 = _mm_load_si128(&v32);
  if ( v5 == (const __m128i *)v11 )
  {
LABEL_24:
    if ( v4 )
    {
      if ( Sizea[0] < 0x10 )
      {
        memcpy(&v32, Src, Sizea[0]);
        v27 = _mm_load_si128(&v32);
      }
      else
      {
        v27 = _mm_loadu_si128(Src);
      }
      do
      {
        v28 = _mm_loadu_si128(v7);
        v29 = _mm_cmpestri(v28, v27, 0x10u, v4);
        if ( _mm_cmpestrc(v28, v27, 0x10u, v4) && v29 > v10 )
          v10 = v29;
        ++v7;
      }
      while ( v7 != v19 );
      if ( v18 )
      {
        v30 = _mm_cmpestri(v20, v27, v18, v4);
        if ( _mm_cmpestrc(v20, v27, v18, v4) )
        {
          if ( v30 > v10 )
            return v30;
        }
      }
      return v10;
    }
    return -1;
  }
  while ( 1 )
  {
    v21 = _mm_loadu_si128(--v5);
    v22 = -1;
    v23 = v7;
    do
    {
      v24 = _mm_loadu_si128(v23);
      v25 = _mm_cmpestri(v24, v21, 0x10u, 0x10u);
      if ( _mm_cmpestrc(v24, v21, 0x10u, 0x10u) && v25 > v22 )
        v22 = v25;
      ++v23;
    }
    while ( v23 != v19 );
    if ( v18 )
    {
      v26 = _mm_cmpestri(v20, v21, v18, 0x10u);
      if ( _mm_cmpestrc(v20, v21, v18, 0x10u) )
      {
        if ( v26 > v22 )
          v22 = v26;
      }
    }
    if ( v22 != -1 )
      return (__int64)v5 + v22 - (_QWORD)Src;
    if ( v5 == (const __m128i *)v11 )
      goto LABEL_24;
  }
}

//----- (000000014000B6B0) ----------------------------------------------------
int __fastcall sub_14000B6B0(char *a1, unsigned __int64 a2)
{
  char *v5; // rdi
  char *v6; // rbx
  char v8; // dl
  unsigned int v9; // ecx
  int result; // eax
  __int64 v17; // rax
  __m256i v42; // [rsp+40h] [rbp+0h] BYREF

  _RBP = (unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0uLL;
  v5 = &a1[a2];
  v6 = a1;
  if ( a2 > 0x14 )
  {
    memset((void *)((unsigned __int64)&v42 & 0xFFFFFFFFFFFFFFE0uLL), 0, 0x100u);
    for ( ; v6 != v5; *(_BYTE *)(_RBP + v17) = -1 )
      v17 = (unsigned __int8)*v6++;
    __asm
    {
      vmovdqu ymm1, [rbp+110h+var_50]
      vmovdqu ymm0, [rbp+110h+var_30]
      vpmovmskb ebx, ymm0
      vmovdqu ymm0, [rbp+110h+var_70]
      vpmovmskb r10d, ymm0
      vmovdqu ymm0, [rbp+110h+var_B0]
      vpmovmskb r8d, ymm0
      vmovdqu ymm0, [rbp+110h+var_F0]
      vpmovmskb ecx, ymm0
      vpmovmskb r11d, ymm1
      vmovdqu ymm1, [rbp+110h+var_90]
      vpmovmskb r9d, ymm1
      vmovdqu ymm1, [rbp+110h+var_D0]
      vpmovmskb edx, ymm1
      vmovdqu ymm1, [rbp+110h+var_110]
      vmovd   xmm0, r9d
      vpinsrd xmm0, xmm0, r10d, 1
      vpinsrd xmm0, xmm0, r11d, 2
      vpmovmskb eax, ymm1
      vmovd   xmm2, eax
      vpinsrd xmm2, xmm2, ecx, 1
      vpinsrd xmm2, xmm2, edx, 2
      vpinsrd xmm2, xmm2, r8d, 3
      vpinsrd xmm0, xmm0, ebx, 3
      vinsertf128 ymm0, ymm2, xmm0, 1
    }
  }
  else
  {
    __asm { vpxor   xmm0, xmm0, xmm0 }
    if ( a1 != v5 )
    {
      do
      {
        v8 = *v6;
        v9 = (unsigned __int8)*v6++;
        _EDX = v8 & 0x3F;
        result = 1 << ((v9 >> 3) & 0x18);
        __asm
        {
          vmovd   xmm1, eax
          vpmovzxbq ymm2, xmm1
          vmovd   xmm1, edx
          vpsllq  ymm2, ymm2, xmm1
          vpor    ymm0, ymm2, ymm0
        }
      }
      while ( v6 != v5 );
    }
  }
  return result;
}

//----- (000000014000B810) ----------------------------------------------------
char __fastcall sub_14000B810(unsigned __int64 a1, unsigned __int64 a2, char a3)
{
  char result; // al

  if ( a3 && a1 > 0x30 )
  {
    if ( a2 > 0x10 )
    {
      if ( a2 > 0x30 )
        return 2;
      else
        return 2 * (a1 > 0x50);
    }
    else
    {
      return 2 * (a1 > 0x3E8);
    }
  }
  else
  {
    result = 0;
    if ( a2 > 0x20 )
    {
      if ( a2 > 0x30 )
      {
        if ( a2 > 0x40 )
        {
          if ( a2 > 0x50 )
          {
            if ( a2 > 0x21C )
              return a1 > 0x20;
            else
              return a1 > 0x30;
          }
          else
          {
            return a1 > 0x80;
          }
        }
        else
        {
          return a1 > 0xE0;
        }
      }
      else
      {
        return a1 > 0x1A0;
      }
    }
  }
  return result;
}

//----- (000000014000B8A0) ----------------------------------------------------
const __m128i *__fastcall sub_14000B8A0(const __m128i *a1, const __m128i *a2, const __m128i *a3, size_t a4)
{
  const __m128i *v7; // rbx
  unsigned __int64 v9; // rcx
  __m128i v10; // xmm6
  __m128i v11; // xmm0
  int v12; // ecx
  unsigned int v13; // esi
  __m128i v14; // xmm0
  int v15; // ecx
  __m128i v16; // xmm6
  const __m128i *v17; // rbp
  const __m128i *v18; // rsi
  __m128i v19; // xmm0
  int v20; // ecx
  __m128i v21; // xmm1
  const __m128i *v22; // rdx
  __int8 v23; // r8
  __int64 v24; // rcx
  __m128i v25; // [rsp+20h] [rbp-58h] BYREF

  v7 = a1;
  if ( !a4 )
    return a1;
  if ( a4 == 1 )
    return sub_14000B390(a1, a2, a3->m128i_i8[0]);
  v9 = (char *)a2 - (char *)a1;
  if ( (char *)a2 - (char *)v7 >= a4 )
  {
    if ( (dword_14001500C & 4) != 0 && v9 >= 0x10 )
    {
      if ( a4 > 0x10 )
      {
        v16 = _mm_loadu_si128(a3);
        v17 = a3 + 1;
        v18 = (const __m128i *)((char *)a2 - a4);
        while ( 1 )
        {
          v19 = _mm_loadu_si128(v7);
          v20 = _mm_cmpestri(v16, v19, 0x10u, 0x10u);
          if ( _mm_cmpestrc(v16, v19, 0x10u, 0x10u) )
          {
            if ( !v20 )
              goto LABEL_23;
            v7 = (const __m128i *)((char *)v7 + v20);
            if ( v7 > v18 )
              return a2;
            v21 = (__m128i)_mm_xor_ps((__m128)v16, (__m128)_mm_loadu_si128(v7));
            if ( _mm_testz_si128(v21, v21) )
            {
LABEL_23:
              if ( !memcmp(&v7[1], v17, a4 - 16) )
                return v7;
            }
            v7 = (const __m128i *)((char *)v7 + 1);
          }
          else
          {
            ++v7;
          }
          if ( v7 > v18 )
            return a2;
        }
      }
      memcpy(&v25, a3, a4);
      v10 = _mm_load_si128(&v25);
      do
      {
        v11 = _mm_loadu_si128(v7);
        v12 = _mm_cmpestri(v10, v11, a4, 0x10u);
        if ( _mm_cmpestrc(v10, v11, a4, 0x10u) )
        {
          v7 = (const __m128i *)((char *)v7 + v12);
          if ( v12 <= 16 - (int)a4 )
            return v7;
        }
        else
        {
          ++v7;
        }
      }
      while ( v7 <= &a2[-1] );
      v13 = (_DWORD)a2 - (_DWORD)v7;
      if ( a2 != v7 )
      {
        memcpy(&v25, v7, (char *)a2 - (char *)v7);
        v14 = _mm_load_si128(&v25);
        v15 = _mm_cmpestri(v10, v14, a4, v13);
        if ( _mm_cmpestrc(v10, v14, a4, v13) )
          return (const __m128i *)((char *)v7 + v15);
      }
    }
    else
    {
      v22 = (const __m128i *)((char *)a2 + 1 - a4);
      if ( v7 != v22 )
      {
        v23 = a3->m128i_i8[0];
        do
        {
          if ( v7->m128i_i8[0] == v23 )
          {
            v24 = 1;
            while ( v7->m128i_i8[v24] == a3->m128i_i8[v24] )
            {
              if ( ++v24 == a4 )
                return v7;
            }
          }
          v7 = (const __m128i *)((char *)v7 + 1);
        }
        while ( v7 != v22 );
      }
    }
  }
  return a2;
}
// 14001500C: using guessed type int dword_14001500C;

//----- (000000014000BABC) ----------------------------------------------------
void *__fastcall sub_14000BABC(__int64 a1)
{
  _QWORD *v2; // rdx
  void *result; // rax

  v2 = malloc(0x10u);
  if ( !v2 )
  {
    std::_Xbad_alloc();
    __debugbreak();
  }
  result = qword_140015510;
  *v2 = qword_140015510;
  v2[1] = a1;
  qword_140015510 = v2;
  return result;
}

//----- (000000014000BB7C) ----------------------------------------------------
_QWORD *__fastcall sub_14000BB7C(_QWORD *a1, char a2)
{
  *a1 = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    j_j_free(a1);
  return a1;
}
// 140010AA8: using guessed type void *type_info::`vftable';

//----- (000000014000C07C) ----------------------------------------------------
__int64 __fastcall sub_14000C07C(__int64 a1, __int64 a2)
{
  __int64 v3; // rcx
  __int64 v4; // rax

  v3 = *(unsigned int *)(*(_QWORD *)(a2 + 16) + 8LL);
  v4 = *(_QWORD *)(a2 + 8);
  if ( (*(_BYTE *)(v3 + v4 + 3) & 0xF) != 0 )
    return a1 + (*(_BYTE *)(v3 + v4 + 3) & 0xF0);
  else
    return a1;
}

//----- (000000014000C0E0) ----------------------------------------------------
__int64 sub_14000C0E0()
{
  int v5; // ebp
  bool v7; // zf
  int v12; // edi
  int v13; // eax
  unsigned __int64 v14; // rax
  __int64 v15; // rcx
  int v16; // r8d
  int v17; // r9d
  unsigned int v18; // r11d
  int v24; // esi
  int v25; // r10d
  unsigned __int64 v36; // rax
  int v37; // eax
  unsigned __int64 v38; // rax
  __int64 v39; // rdx
  int v41; // [rsp+20h] [rbp+8h]

  _RAX = 0;
  __asm { cpuid }
  v5 = _RAX;
  _RAX = 1;
  v7 = ((unsigned int)_RBX ^ 0x756E6547 | (unsigned int)_RCX ^ 0x6C65746E | (unsigned int)_RDX ^ 0x49656E69) == 0;
  __asm { cpuid }
  v12 = _RCX;
  if ( v7
    && ((v13 = _RAX & 0xFFF3FF0, qword_140015010 = 0x8000, qword_140015018 = -1, v13 == 67264)
     || v13 == 132704
     || v13 == 132720
     || (v14 = (unsigned int)(v13 - 198224), (unsigned int)v14 <= 0x20) && (v15 = 0x100010001LL, _bittest64(&v15, v14))) )
  {
    v16 = dword_140015568 | 1;
    dword_140015568 |= 1u;
  }
  else
  {
    v16 = dword_140015568;
  }
  v17 = 0;
  v18 = 0;
  if ( v5 < 7 )
  {
    v25 = 0;
    v24 = 0;
  }
  else
  {
    _RAX = 7;
    __asm { cpuid }
    v24 = _RDX;
    v25 = _RBX;
    if ( (_RBX & 0x200) != 0 )
      dword_140015568 = v16 | 2;
    if ( (int)_RAX >= 1 )
    {
      _RAX = 7;
      __asm { cpuid }
      v17 = _RDX;
    }
    _RAX = 36;
    if ( v5 >= 36 )
    {
      __asm { cpuid }
      v18 = _RBX;
    }
  }
  v36 = qword_140015020 & 0xFFFFFFFFFFFFFFFEuLL;
  dword_140015008 = 1;
  dword_14001500C = 2;
  qword_140015020 &= ~1uLL;
  if ( (v12 & 0x100000) != 0 )
  {
    v36 &= ~0x10uLL;
    dword_140015008 = 2;
    qword_140015020 = v36;
    dword_14001500C = 6;
  }
  if ( (v12 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    v41 = v36;
    if ( (v12 & 0x10000000) == 0 || (v36 & 6) != 6 )
    {
LABEL_33:
      if ( (v17 & 0x200000) != 0 && (*(_QWORD *)&v41 & 0x80000LL) != 0 )
        qword_140015020 &= ~0x80uLL;
      return 0;
    }
    v37 = dword_14001500C | 8;
    dword_140015008 = 3;
    dword_14001500C |= 8u;
    if ( (v25 & 0x20) != 0 )
    {
      dword_140015008 = 5;
      dword_14001500C = v37 | 0x20;
      v38 = qword_140015020 & 0xFFFFFFFFFFFFFFFDuLL;
      qword_140015020 &= ~2uLL;
      if ( (v25 & 0xD0030000) != 0xD0030000 )
      {
LABEL_27:
        if ( (v24 & 0x800000) != 0 )
          qword_140015020 = v38 & 0xFFFFFFFFFEFFFFFFuLL;
        if ( (v17 & 0x80000) != 0 && (v41 & 0xE0) == 0xE0 )
        {
          dword_14001556C = v18 & 0x400FF;
          v39 = ~(HIWORD(v18) & 6 | 0x1000029LL) & qword_140015020;
          qword_140015020 = v39;
          if ( (unsigned __int8)v18 > 1u )
            qword_140015020 = v39 & 0xFFFFFFFFFFFFFFBFuLL;
        }
        goto LABEL_33;
      }
      if ( (v41 & 0xE0) == 0xE0 )
      {
        dword_14001500C |= 0x40u;
        v38 = qword_140015020 & 0xFFFFFFFFFFFFFFDBuLL;
        dword_140015008 = 6;
        qword_140015020 &= 0xFFFFFFFFFFFFFFDBuLL;
        goto LABEL_27;
      }
    }
    v38 = qword_140015020;
    goto LABEL_27;
  }
  return 0;
}
// 14000C0E0: using guessed type __int64 sub_14000C0E0();
// 140015008: using guessed type int dword_140015008;
// 14001500C: using guessed type int dword_14001500C;
// 140015010: using guessed type __int64 qword_140015010;
// 140015018: using guessed type __int64 qword_140015018;
// 140015020: using guessed type __int64 qword_140015020;
// 140015568: using guessed type int dword_140015568;
// 14001556C: using guessed type int dword_14001556C;

//----- (000000014000C388) ----------------------------------------------------
_QWORD *__fastcall sub_14000C388(_QWORD *a1)
{
  a1[2] = 0;
  a1[1] = "bad allocation";
  *a1 = &std::bad_alloc::`vftable';
  return a1;
}
// 140010AD0: using guessed type void *std::bad_alloc::`vftable';

//----- (000000014000C3AC) ----------------------------------------------------
void __noreturn sub_14000C3AC()
{
  _QWORD pExceptionObject[5]; // [rsp+20h] [rbp-28h] BYREF

  sub_14000C388(pExceptionObject);
  throw (std::bad_alloc *)pExceptionObject;
}
// 14000C3AC: using guessed type void __noreturn sub_14000C3AC();

//----- (000000014000C3F0) ----------------------------------------------------
__int64 __fastcall UserMathErrorFunction(struct _exception *a1)
{
  return 0;
}

//----- (000000014000C3F4) ----------------------------------------------------
bool sub_14000C3F4()
{
  HMODULE ModuleHandleW; // rax
  __int64 v1; // rcx
  bool result; // al

  ModuleHandleW = GetModuleHandleW(0);
  result = ModuleHandleW
        && *(_WORD *)ModuleHandleW == 23117
        && (v1 = *((int *)ModuleHandleW + 15), *(_DWORD *)((char *)ModuleHandleW + v1) == 17744)
        && *(_WORD *)((char *)ModuleHandleW + v1 + 24) == 523
        && *(_DWORD *)((char *)ModuleHandleW + v1 + 132) > 0xEu
        && *(_DWORD *)((char *)ModuleHandleW + v1 + 248) != 0;
  return result;
}

//----- (000000014000C4B4) ----------------------------------------------------
__int64 sub_14000C4B4()
{
  uintptr_t v0; // rax
  __int64 result; // rax
  struct _FILETIME v2; // [rsp+20h] [rbp-10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+10h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+48h] [rbp+18h] BYREF

  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232LL )
  {
    SystemTimeAsFileTime = 0;
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = SystemTimeAsFileTime;
    v2 = (struct _FILETIME)(GetCurrentThreadId() ^ *(unsigned __int64 *)&v2);
    v2 = (struct _FILETIME)(GetCurrentProcessId() ^ *(unsigned __int64 *)&v2);
    QueryPerformanceCounter(&PerformanceCount);
    v0 = ((unsigned __int64)&v2
        ^ *(_QWORD *)&v2
        ^ PerformanceCount.QuadPart
        ^ ((unsigned __int64)PerformanceCount.LowPart << 32))
       & 0xFFFFFFFFFFFFLL;
    if ( v0 == 0x2B992DDFA232LL )
      v0 = 0x2B992DDFA233LL;
    _security_cookie = v0;
  }
  result = ~v0;
  qword_140015080 = result;
  return result;
}
// 14000C4B4: using guessed type __int64 sub_14000C4B4();
// 140015080: using guessed type __int64 qword_140015080;

//----- (000000014000C56C) ----------------------------------------------------
void sub_14000C56C()
{
  InitializeSListHead(&stru_140015580);
}
// 140015580: using guessed type union _SLIST_HEADER stru_140015580;

//----- (000000014000C57C) ----------------------------------------------------
char sub_14000C57C()
{
  return 1;
}

//----- (000000014000C580) ----------------------------------------------------
void *sub_14000C580()
{
  return &unk_140015590;
}

//----- (000000014000C5B0) ----------------------------------------------------
void *sub_14000C5B0()
{
  return &unk_1400155D8;
}

//----- (000000014000C5B8) ----------------------------------------------------
void *sub_14000C5B8()
{
  return &unk_1400155D0;
}

//----- (000000014000C5C0) ----------------------------------------------------
void sub_14000C5C0()
{
  void (**i)(void); // rbx

  for ( i = qword_140012078; i < qword_140012078; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140012078: using guessed type void (*qword_140012078[2])(void);

//----- (000000014000C5FC) ----------------------------------------------------
void __fastcall sub_14000C5FC()
{
  void (**i)(void); // rbx

  for ( i = &qword_140012088; i < &qword_140012088; ++i )
  {
    if ( *i )
      (*i)();
  }
}
// 140012088: using guessed type void (*qword_140012088)(void);

//----- (000000014000C850) ----------------------------------------------------
__int64 __fastcall sub_14000C850(__int64 a1, __int64 a2)
{
  return sub_1400010C0(*(_QWORD *)(a2 + 80));
}
// 1400010C0: using guessed type __int64 __fastcall sub_1400010C0(_QWORD);

//----- (000000014000C8AF) ----------------------------------------------------
__int64 __fastcall sub_14000C8AF(__int64 a1, __int64 a2)
{
  return sub_140001B50(a2 + 128);
}
// 140001B50: using guessed type __int64 __fastcall sub_140001B50(_QWORD);

//----- (000000014000C950) ----------------------------------------------------
__int64 __fastcall sub_14000C950(__int64 a1, __int64 a2)
{
  return sub_1400010C0(*(_QWORD *)(a2 + 48));
}
// 1400010C0: using guessed type __int64 __fastcall sub_1400010C0(_QWORD);

//----- (000000014000C9A0) ----------------------------------------------------
__int64 __fastcall sub_14000C9A0(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 120);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000C9AC) ----------------------------------------------------
__int64 __fastcall sub_14000C9AC(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 120);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000C9E0) ----------------------------------------------------
__int64 __fastcall sub_14000C9E0(__int64 a1, __int64 a2)
{
  return sub_140005680(a2 + 160);
}
// 140005680: using guessed type __int64 __fastcall sub_140005680(_QWORD);

//----- (000000014000CA88) ----------------------------------------------------
__int64 __fastcall sub_14000CA88(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CAA0) ----------------------------------------------------
__int64 __fastcall sub_14000CAA0(__int64 a1, __int64 a2)
{
  return sub_140005720(a2 + 64);
}
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (000000014000CAC4) ----------------------------------------------------
__int64 __fastcall sub_14000CAC4(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CAD0) ----------------------------------------------------
__int64 __fastcall sub_14000CAD0(__int64 a1, __int64 a2)
{
  return sub_140005720(a2 + 72);
}
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (000000014000CAF4) ----------------------------------------------------
__int64 __fastcall sub_14000CAF4(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 104);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB00) ----------------------------------------------------
__int64 __fastcall sub_14000CB00(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 208);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB0C) ----------------------------------------------------
__int64 __fastcall sub_14000CB0C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 104);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB24) ----------------------------------------------------
__int64 __fastcall sub_14000CB24(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 72);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB30) ----------------------------------------------------
__int64 __fastcall sub_14000CB30(__int64 a1, __int64 a2)
{
  return sub_140001310(a2 + 208);
}
// 140001310: using guessed type __int64 __fastcall sub_140001310(_QWORD);

//----- (000000014000CB48) ----------------------------------------------------
__int64 __fastcall sub_14000CB48(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 40);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB54) ----------------------------------------------------
__int64 __fastcall sub_14000CB54(__int64 a1, __int64 a2)
{
  return sub_140005720(a2 + 40);
}
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (000000014000CB60) ----------------------------------------------------
__int64 __fastcall sub_14000CB60(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 112);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB6C) ----------------------------------------------------
__int64 __fastcall sub_14000CB6C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 240);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB78) ----------------------------------------------------
__int64 __fastcall sub_14000CB78(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 112);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CB84) ----------------------------------------------------
__int64 __fastcall sub_14000CB84(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 40);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CBA0) ----------------------------------------------------
__int64 __fastcall sub_14000CBA0(__int64 a1, __int64 a2)
{
  return sub_140005720(a2 + 64);
}
// 140005720: using guessed type __int64 __fastcall sub_140005720(_QWORD);

//----- (000000014000CC18) ----------------------------------------------------
__int64 __fastcall sub_14000CC18(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 160);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CC3C) ----------------------------------------------------
__int64 __fastcall sub_14000CC3C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 192);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CC48) ----------------------------------------------------
__int64 __fastcall sub_14000CC48(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 224);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CC54) ----------------------------------------------------
__int64 __fastcall sub_14000CC54(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 192);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CC6C) ----------------------------------------------------
__int64 __fastcall sub_14000CC6C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CC78) ----------------------------------------------------
__int64 __fastcall sub_14000CC78(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 96);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CCD4) ----------------------------------------------------
__int64 __fastcall sub_14000CCD4(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CCE0) ----------------------------------------------------
__int64 __fastcall sub_14000CCE0(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CCEC) ----------------------------------------------------
__int64 __fastcall sub_14000CCEC(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 64);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CD00) ----------------------------------------------------
__int64 __fastcall sub_14000CD00(__int64 a1, __int64 a2)
{
  return sub_140001310(a2 + 72);
}
// 140001310: using guessed type __int64 __fastcall sub_140001310(_QWORD);

//----- (000000014000CD0C) ----------------------------------------------------
__int64 __fastcall sub_14000CD0C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 40);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CD2C) ----------------------------------------------------
__int64 __fastcall sub_14000CD2C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 48);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CD60) ----------------------------------------------------
__int64 __fastcall sub_14000CD60(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 304);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CDBC) ----------------------------------------------------
__int64 __fastcall sub_14000CDBC(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 72);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CDC8) ----------------------------------------------------
__int64 __fastcall sub_14000CDC8(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 208);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CDD4) ----------------------------------------------------
__int64 __fastcall sub_14000CDD4(__int64 a1, __int64 a2)
{
  return sub_140006E90(a2 + 400);
}
// 140006E90: using guessed type __int64 __fastcall sub_140006E90(_QWORD);

//----- (000000014000CDE0) ----------------------------------------------------
__int64 __fastcall sub_14000CDE0(__int64 a1, __int64 a2)
{
  return sub_140007940(a2 + 240);
}
// 140007940: using guessed type __int64 __fastcall sub_140007940(_QWORD);

//----- (000000014000CDEC) ----------------------------------------------------
__int64 __fastcall sub_14000CDEC(__int64 a1, __int64 a2)
{
  return sub_140002CE0(a2 + 288);
}
// 140002CE0: using guessed type __int64 __fastcall sub_140002CE0(_QWORD);

//----- (000000014000CDF8) ----------------------------------------------------
__int64 __fastcall sub_14000CDF8(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 72);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CE50) ----------------------------------------------------
void __fastcall sub_14000CE50(__int64 a1, __int64 a2)
{
  std::_Lockit::~_Lockit((std::_Lockit *)(a2 + 40));
}
// 14000E178: using guessed type void std::_Lockit::~_Lockit(std::_Lockit *__hidden this);

//----- (000000014000CEC0) ----------------------------------------------------
__int64 __fastcall sub_14000CEC0(__int64 a1, __int64 a2)
{
  return sub_140006C40(a2 + 96);
}
// 140006C40: using guessed type __int64 __fastcall sub_140006C40(_QWORD);

//----- (000000014000CEF0) ----------------------------------------------------
__int64 __fastcall sub_14000CEF0(__int64 a1, __int64 a2)
{
  return sub_140001310(a2 + 168);
}
// 140001310: using guessed type __int64 __fastcall sub_140001310(_QWORD);

//----- (000000014000CEFC) ----------------------------------------------------
__int64 __fastcall sub_14000CEFC(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 56);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CF10) ----------------------------------------------------
__int64 __fastcall sub_14000CF10(__int64 a1, __int64 a2)
{
  return sub_140001310(a2 + 208);
}
// 140001310: using guessed type __int64 __fastcall sub_140001310(_QWORD);

//----- (000000014000CF1C) ----------------------------------------------------
__int64 __fastcall sub_14000CF1C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 72);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CF28) ----------------------------------------------------
__int64 __fastcall sub_14000CF28(__int64 a1, __int64 a2)
{
  return sub_140009CA0(a2 + 176);
}
// 140009CA0: using guessed type __int64 __fastcall sub_140009CA0(_QWORD);

//----- (000000014000CF40) ----------------------------------------------------
__int64 __fastcall sub_14000CF40(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 48);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CF50) ----------------------------------------------------
__int64 __fastcall sub_14000CF50(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 184);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CF5C) ----------------------------------------------------
__int64 __fastcall sub_14000CF5C(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 48);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000CF70) ----------------------------------------------------
__int64 __fastcall sub_14000CF70(__int64 a1, __int64 a2)
{
  return sub_140001310(a2 + 40);
}
// 140001310: using guessed type __int64 __fastcall sub_140001310(_QWORD);

//----- (000000014000CFF9) ----------------------------------------------------
__int64 __fastcall sub_14000CFF9(__int64 a1, __int64 a2)
{
  return sub_140009170(a2 + 64);
}
// 140009170: using guessed type __int64 __fastcall sub_140009170(_QWORD);

//----- (000000014000D005) ----------------------------------------------------
__int64 __fastcall sub_14000D005(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D011) ----------------------------------------------------
__int64 __fastcall sub_14000D011(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D01D) ----------------------------------------------------
__int64 __fastcall sub_14000D01D(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D029) ----------------------------------------------------
__int64 __fastcall sub_14000D029(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D035) ----------------------------------------------------
__int64 __fastcall sub_14000D035(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D041) ----------------------------------------------------
__int64 __fastcall sub_14000D041(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D04D) ----------------------------------------------------
__int64 __fastcall sub_14000D04D(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 840);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D059) ----------------------------------------------------
__int64 __fastcall sub_14000D059(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 760);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D065) ----------------------------------------------------
__int64 __fastcall sub_14000D065(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 840);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D071) ----------------------------------------------------
__int64 __fastcall sub_14000D071(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 840);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D0A0) ----------------------------------------------------
__int64 __fastcall sub_14000D0A0(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 168);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D0AC) ----------------------------------------------------
__int64 __fastcall sub_14000D0AC(__int64 a1, __int64 a2)
{
  return sub_140001D90(a2 + 128);
}
// 140001D90: using guessed type __int64 __fastcall sub_140001D90(_QWORD);

//----- (000000014000D0C0) ----------------------------------------------------
__int64 __fastcall sub_14000D0C0(__int64 a1, __int64 a2)
{
  return sub_14000B090(a2 + 48);
}
// 14000B090: using guessed type __int64 __fastcall sub_14000B090(_QWORD);

//----- (000000014000D110) ----------------------------------------------------
void __fastcall sub_14000D110()
{
  char *v0; // rcx

  if ( (unsigned __int64)qword_1400155C0 > 0xF )
  {
    if ( (unsigned __int64)(qword_1400155C0 + 1) < 0x1000 )
    {
      v0 = Block;
    }
    else
    {
      v0 = (char *)*((_QWORD *)Block - 1);
      if ( (unsigned __int64)(Block - v0 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v0);
  }
  qword_1400155B8 = 0;
  qword_1400155C0 = 15;
  LOBYTE(Block) = 0;
}
// 1400155B8: using guessed type __int64 qword_1400155B8;
// 1400155C0: using guessed type __int64 qword_1400155C0;

//----- (000000014000D180) ----------------------------------------------------
void sub_14000D180()
{
  _BYTE *v0; // rcx

  if ( (unsigned __int64)qword_1400150B0 > 0xF )
  {
    if ( (unsigned __int64)(qword_1400150B0 + 1) < 0x1000 )
    {
      v0 = qword_140015098;
    }
    else
    {
      v0 = (_BYTE *)*((_QWORD *)qword_140015098 - 1);
      if ( (unsigned __int64)((_BYTE *)qword_140015098 - v0 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v0);
  }
  qword_1400150A8 = 0;
  qword_1400150B0 = 15;
  LOBYTE(qword_140015098) = 0;
}
// 1400150A8: using guessed type __int64 qword_1400150A8;
// 1400150B0: using guessed type __int64 qword_1400150B0;

//----- (000000014000D1F0) ----------------------------------------------------
void sub_14000D1F0()
{
  void *v0; // rcx

  if ( (unsigned __int64)qword_1400150D0 > 0xF )
  {
    if ( (unsigned __int64)(qword_1400150D0 + 1) < 0x1000 )
    {
      v0 = aLoader[0];
    }
    else
    {
      v0 = (void *)*((_QWORD *)aLoader[0] - 1);
      if ( (unsigned __int64)((char *)aLoader[0] - (char *)v0 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v0);
  }
  qword_1400150C8 = 0;
  qword_1400150D0 = 15;
  LOBYTE(aLoader[0]) = 0;
}
// 1400150C8: using guessed type __int64 qword_1400150C8;
// 1400150D0: using guessed type __int64 qword_1400150D0;

//----- (000000014000D260) ----------------------------------------------------
void sub_14000D260()
{
  void *v0; // rcx

  if ( (unsigned __int64)qword_140015110 > 0xF )
  {
    if ( (unsigned __int64)(qword_140015110 + 1) < 0x1000 )
    {
      v0 = aLoad[0];
    }
    else
    {
      v0 = (void *)*((_QWORD *)aLoad[0] - 1);
      if ( (unsigned __int64)((char *)aLoad[0] - (char *)v0 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v0);
  }
  qword_140015108 = 0;
  qword_140015110 = 15;
  LOBYTE(aLoad[0]) = 0;
}
// 140015108: using guessed type __int64 qword_140015108;
// 140015110: using guessed type __int64 qword_140015110;

//----- (000000014000D2D0) ----------------------------------------------------
void sub_14000D2D0()
{
  void *v0; // rcx

  if ( (unsigned __int64)qword_1400150F0 > 0xF )
  {
    if ( (unsigned __int64)(qword_1400150F0 + 1) < 0x1000 )
    {
      v0 = aYinyiDll[0];
    }
    else
    {
      v0 = (void *)*((_QWORD *)aYinyiDll[0] - 1);
      if ( (unsigned __int64)((char *)aYinyiDll[0] - (char *)v0 - 8) > 0x1F )
        __fastfail(5u);
    }
    j_j_free(v0);
  }
  qword_1400150E8 = 0;
  qword_1400150F0 = 15;
  LOBYTE(aYinyiDll[0]) = 0;
}
// 1400150E8: using guessed type __int64 qword_1400150E8;
// 1400150F0: using guessed type __int64 qword_1400150F0;

//----- (000000014000D33C) ----------------------------------------------------
void sub_14000D33C()
{
  __int64 v0; // rcx
  void (__fastcall ***v1)(_QWORD, __int64); // rax
  void *v2; // rbx

  while ( 1 )
  {
    v2 = qword_140015510;
    if ( !qword_140015510 )
      break;
    v0 = *((_QWORD *)qword_140015510 + 1);
    qword_140015510 = *(void **)qword_140015510;
    v1 = (void (__fastcall ***)(_QWORD, __int64))(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v0 + 16LL))(v0);
    if ( v1 )
      (**v1)(v1, 1);
    free(v2);
  }
}

// #eh34_calls=0 #try=2 #catch=2 #wind=0 #gotos=150
// nfuncs=389 queued=214 decompiled=214 lumina nreq=0 worse=0 better=0
// ALL OK, 214 function(s) have been successfully decompiled
